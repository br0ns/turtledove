\documentclass[a4paper,oneside]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF
\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{listings}
\usepackage{amssymb}

\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.

\lstset{ %
% language=Octave,                % choose the language of the code
basicstyle=\ttfamily,        % the size of the fonts that are used for the code
basewidth=0.5em,
% numbers=left,                   % where to put the line-numbers
% numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
% stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
% numbersep=5pt,                  % how far the line-numbers are from the code
% backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
% showspaces=false,               % show spaces adding particular underscores
% showstringspaces=false,         % underline spaces within strings
% showtabs=false,                 % show tabs within strings adding particular underscores
% frame=single	                % adds a frame around the code
% tabsize=2,	                % sets default tabsize to 2 spaces
% captionpos=b,                   % sets the caption-position to bottom
% breaklines=true,                % sets automatic line breaking
% breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={(@}{@)}          % if you want to add a comment within your code
}

\author{Morten Brøns-Pedersen \and Jesper Reenberg}
\title{Synopsis}

\begin{document}

\maketitle

\fixme{Search and replace ``plugins'' with new word ``tools''}
\fixme{Search and replace ``IDE'' -> ``editor''}
\fixme{Search and replace ``front end'' -> ``user interface''}
\fixme{skift alle itemize ud med enumerate så der kan henvises til specifikke punkter uden for denne}

%% Vi skal skifte drejningen til at handle om værktøjet. Vores motivation er at lave det værktøj. Undgå
%% at bruge modulnavne i synopsen. Når man læser den er det ikke sikkert man har læst eller har tænkt
%% sig at læse kildekoden.

%% Navngivning:
%%   Programmet hedder Turtledove. Værktøjet har intet navn men kan identificeres med Turtledove idet
%%   der ikke laves andre værktøjer

%% Logisk opbygning:
%%   Title
%%   Motivation
%%     Tool assisted programming i almindelighed
%%     Vores værktøj specielt
%%   Elaboration
%%     Vi ønsker at opdele udviklingen af Turtledove og front-end'en.
%%       Kommunikation foregår via tekststrømme
%%     Hvad skal vores værktøj kunne, (næsten) helt præcist?
%%       Kodeeksempler
%%     For at lette udviddelsen af Turtledove vil vi prøve at holde en vis grad af modularitet
%%       API
%%       Libs
%%   Primary goals
%%   Secondary goals (nice to haves skal herunder)
%%   Limitations
%%   Learning objective
%%   Tasks and timeline


\section{Title}
``Turtledove: Tool assisted programming in SML, with special emphasis on semi-automatic
rewriting.''\fixme{Længere titel.}

\section{Motivation}
Today functional programming languages are not very widespread outside academic circles. A major
reason for this may be that not as rich development environments exists (if at all) for functional
programming languages compared to certain imperative languages (take languages in the .NET platform
as an example).

We wish to make functional programming, specifically in SML, easier to approach for the beginner as
well as more advantageous for the veteran.

Functional programming languages has a wide variety of advantages that makes them specially suited
for quick and correct statical analysis. The effect of this is that it will be possible to make more
complex tools for functional programming languages than for imperative ones.
\fixme{Er det dumt at hævde disse ting uden et opfølgende argument?}

We implement semi-automatic rewriting of terms according to a set of predefined rules. We focus on
modularity such that it will be relatively simple to implement other tools based on our software in
the future.
\fixme{Hvorfor dette værktøj? i) Vi behøver ikke regne typer, ii) vi får lov at føre nogle fine
beviser, iii) med omskrivning kan vi let implementere flere forskellige værktøjer - især hvis vi
implementerer den transitive afslutning af (dele af) omskrivningerne (tænk reduktioner).}

%% Experienced programmers will find that code complying to certain standard patterns is easier to
%% read. Another advantage of standard patterns is that compilers are able to specially optimize these,
%% possibly making such code faster.

\section{Elaboration}
We wish to be able to suggest possible rewritings to the programmer in real time, based on some
predefined rules.

This implies that our tool is initiated and responds through some user interface. There are two good
reasons why we wish to be able to develop our tool and its user interface separately:
\begin{enumerate}
\item As different programmers use different editors and generally have strong feelings
      about their choice we do not see it as an option to implement a new editor. Instead a user
      interface would be implemented on top of an existing editor. We do not wish to bind our
      tool to a single one.
\item It is not the goal of this project to implement a user interface for tool assisted
      programming.
\end{enumerate}

Since the user interface and the tool are two distinct pieces of software we have to decide a way
for them to communicate.

\subsection{Semi-automatic rewriting}
We define a set of rewriting rules:
\begin{eqnarray*}
t_0 &\rightarrow& t_0'\\
&\vdots&\\
t_n &\rightarrow& t_n'
\end{eqnarray*}

where $t_i$ and $t_i'$ are program terms and the free variables of $t_i'$ is a subset of the free
variables of $t_i$.
\\

A term $u$ is an instance of a term $t$ if and only if there exists terms $x_i$ such that
\begin{eqnarray}\label{eq:term-instance}
t[x_0 / v_0] \cdots [x_n / v_n] =_{\alpha} u
\end{eqnarray}
where $v_0, \ldots, v_n$ are the free variables of $t$.

The rule $t \rightarrow t'$ applies to $u$ with the result
\begin{eqnarray}\label{eq:term-result}
u' =_{\alpha} t'[x_0 / v_0] \cdots [x_n / v_n]
\end{eqnarray}
where the name mapping implied by the alpha equivalence of (\ref{eq:term-instance}) corresponds to
that of (\ref{eq:term-result}).

Notice that the free variables of $t'$ is a subset of $\{v_0, \ldots, v_n\}$.

\subsubsection{Rule labeling and grouping}
A large set of rewriting rules suggesting a large amount of rewritings may confuse the programmer as
to which rewritings is used in which places. Therefore we label each rule with a name and an
optional description.

Since some rules group naturally together (e.g., multiple rules for rewriting boolean expressions)
we make it possible to arrange multiple rules under a common group name.

Grouping and labeling makes it easier for the programmer to see what is going on. It could also make
it possible to turn on or off individual groups of rules or specific rules as well as computing the
transitive closure of groups of rules.

\subsubsection{Example}\label{sec:example}
Consider the following rewriting rule for a standard map form:
\begin{eqnarray}[TlcTl]
\begin{lstlisting}
fun f nil       = nil
  | f (x :: xs) = (@$\heartsuit$@) :: f xs
\end{lstlisting}
&
\
\rightarrow
\
&
\begin{lstlisting}
val f = map (fn x => (@$\heartsuit$@))
\end{lstlisting}\label{eq:rule-map}
\end{eqnarray}

Keep in mind that the \texttt{x} on the right hand side is related to the \texttt{x} on the left
as illustrated below.

The term
\begin{eqnarray}[Tl]\label{eq:term-gt}
\begin{lstlisting}
fun gt nil       = nil
  | gt (n :: ns) = n > 0 :: gt ns
\end{lstlisting}
\end{eqnarray}
is an instance of the left hand side of (\ref{eq:rule-map}) with instantiation
\begin{eqnarray*}[TlcTl]
$\heartsuit$
&
\ =\
&
\texttt{n > 0}
\end{eqnarray*}
and alpha conversion
\begin{eqnarray*}[TlcTl]
\texttt{f}
&
\ =\
&
\texttt{gt}\\
\texttt{x}
&
\ =\
&
\texttt{n}\\
\texttt{xs}
&
\ =\
&
\texttt{ns}
\end{eqnarray*}

Now using (\ref{eq:rule-map}) we get the result
\begin{eqnarray}[Tl]\label{eq:term-gt-result}
\begin{lstlisting}
val gt = map (fn n => n > 0)
\end{lstlisting}
\end{eqnarray}

\subsection{Turtledove}
Our implementation of the described tool is named Turtledove.
\\

Since we intent that Turtledove should grow to include more than one tool we design it in such a
way as to accommodate this. This means that functionality unique to a specific tool should be
separated from functionality common to most tools.

Common functionality is split between core functionality needed by every tool and a collection of
libraries that make it easier to perform common tasks.

\subsubsection{Core functionality}
The core functionality of Turtledove includes:\fixme{Tilføj ``but is not limited to''?}
\begin{enumerate}
\item Turtledove will take the path of an SML file or a project file either as a command line
  argument or through the user interface after it has been started. It then reads and parses the
  file or files contained in the project.

  The user interface should signal when a file is changed and possibly what has changed within that
  file. The one extreme is to signal a file change only when a file is saved. The other is to signal
  every key stroke. Testing will reveal the right balance.
  \fixme{For implementationsspecifikt?}

  Tools shall be signalled when the source code has changed.

\item Data is guided between the user interface and its destination. Communication is done over a
  protocol flexible enough to allow each destination to implement its own protocol.
\end{enumerate}

\section{Primary goals}
To summarize; Turtledove should be able to

\begin{enumerate}
\item Read single SML files or projects.
\item Analyze those files and suggest rewritings as described above.
\item Be signalled when a file changes and suggest new rewritings if any.
\end{enumerate}

We will implement rules for at least two rewritings: Map forms (as demonstrated in Section
\ref{sec:example}) and fold forms.

Equivalence of terms and their transformed counterparts should ideally be proven. We acknowledge the
complexity of such a proof, and is thus satisfied with a good argument.

\section{Secondary goals}

\fixme{Bør dette være med i synopsis, høre det ikke mere hjemme i selve
  rapporten? Evt kunne en meget forsimplet udgave af denne liste indgå i
  synopsen i stedet}
Should time allow it here follows a non-exhaustive list of further work:

\begin{enumerate}

\item Implement project management. A project manager should at least make it easy for the user to
  add and remove files from a project. The project manager should write changes to the SML basis
  file containing the project to disk on the programmers behalf.

\item Make a nice user interface. Probably for Emacs as we use it ourselves and thus have more
  experience with this editor than others.

\item Extend the various parsers to be incremental where applicable (e.g., the parser for SML source
  code). The benefit would be speed gains for reparsing of files with small changes, which is often
  the case.

\item Extend the various parsers to handle syntax errors, for example by skipping the source code
  until the next valid declaration is found. The location in the skipped line of code where the
  first error were found should then be reported back to the user interface such that it can do
  proper notification to the user (e.g., underlining of erroneous code).

% Husk : Måske muligt med SML-Yacc..?

\item Implement transitive closures. Each rewriting rule or group of rules define a relation on
  terms. We suspect that some interesting rewritings can be defined as the transitive closure of a
  rule or a group of rules. An annotation in the rule or rule group will tell Turtledove whether it
  should compute the transitive closure of a rule or not.

\item Add a simplification group of term rewriting rules. Consider the rule \texttt{fn x => g x
    $\rightarrow$ g} as an example.

  When defining a rule it shall be possible to try other rules on the resulting term. The map rule
  from Section \ref{sec:example} will benefit from applying the above rule to its output. Of course
  if the rule does not match it should do nothing.

  Another option is to always try to apply a set of simplifying rules to the output of any rule.

\item Extend the IO file/source code handling part of the program to have a ``patch'' system such
  that code written in the editor is reflected ``live'' if the SML parser decides to parse the
  source files, even if the source files haven't been saved recently.

\item Extend Turtledove such that the SML source code parser can report back ``DocString''
  information\footnote{A short description of a value or function as known from for example Eclipse
    or Visual Studio} to the user interface which in turn can inform the user in an appropriate way.

\item Various parsings of the syntax tree to for example gradually remove syntactic sugar.
  \begin{itemize}
  \item With this a notion of ``run levels'' could be introduced, so at the end of each parsing all
    tools that hook this level will be notified and able to act upon this specific version of the
    parse tree. While the next parse of the syntax tree should continue if there is tools depending
    on one of the next run levels.
  \end{itemize}
\end{enumerate}

\section{Limitations}

\begin{enumerate}
\item Turtledove need not be able to read CM project files.

\item The SML parser need not handle syntax errors.

\item Changes to unsaved files need not be reflected inside Turtledove.

\item No user documentation of software will be produced (e.g., manual, user guide).
\end{enumerate}

\section{Learning objectives}

\begin{enumerate}
\item To develop structured, flexible and well-documented software for manipulation of source code.
\item To understand and describe source code transformations formally, and to implement such
  transformations.
\end{enumerate}


\section{Tasks}

\begin{enumerate}

\item Design an API for intercommunication between the user interface and
  Turtledove.

\item Implement a parser that can parse \textit{.mlb} project files
  \url{http://www.itu.dk/research/mlkit/index.php/ML_Basis_Files}

\item Design the structure of the concrete syntax tree and decide which approach and data type to
  implement it as.

\item Implement a parser that can parse SML code.

\item Design the term rewriting tool.

\item Implement a set of rewriting terms

\item Implement a project manager that given a set of file parsers (e.g., the \textit{.mlb} project
  file parser) exposes an API such that a list of names and paths can be queried from the file
  parser, for example.

\item Extend the project manager such that it at some point can implement smart IO handling of the
  source files.

\item Implement the designed API for intercommunication between the user interface and Turtledove.

\item Analyze Turtledove and apply threading where needed (e.g., the parser for SML code and
  Turtledove itself).

\end{enumerate}


\end{document}
