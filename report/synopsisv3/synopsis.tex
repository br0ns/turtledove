\documentclass[a4paper,oneside]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF
\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{listings}
\usepackage{amssymb}

\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.

\lstset{ %
% language=Octave,                % choose the language of the code
basicstyle=\ttfamily,        % the size of the fonts that are used for the code
basewidth=0.5em,
% numbers=left,                   % where to put the line-numbers
% numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
% stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
% numbersep=5pt,                  % how far the line-numbers are from the code
% backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
% showspaces=false,               % show spaces adding particular underscores
% showstringspaces=false,         % underline spaces within strings
% showtabs=false,                 % show tabs within strings adding particular underscores
% frame=single	                % adds a frame around the code
% tabsize=2,	                % sets default tabsize to 2 spaces
% captionpos=b,                   % sets the caption-position to bottom
% breaklines=true,                % sets automatic line breaking
% breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={(@}{@)}          % if you want to add a comment within your code
}

\author{Morten Brøns-Pedersen \and Jesper Reenberg}
\title{Synopsis}

\begin{document}

\maketitle

\fixme{Search and replace ``plugins'' with new word ``tools''}
\fixme{Search and replace ``IDE'' -> ``editor''}
\fixme{Search and replace ``front end'' -> ``user interface''}

%% Vi skal skifte drejningen til at handle om værktøjet. Vores motivation er at lave det værktøj. Undgå
%% at bruge modulnavne i synopsen. Når man læser den er det ikke sikkert man har læst eller har tænkt
%% sig at læse kildekoden.

%% Navngivning:
%%   Programmet hedder Turtledove. Værktøjet har intet navn men kan identificeres med Turtledove idet
%%   der ikke laves andre værktøjer

%% Logisk opbygning:
%%   Title
%%   Motivation
%%     Tool assisted programming i almindelighed
%%     Vores værktøj specielt
%%   Elaboration
%%     Vi ønsker at opdele udviklingen af Turtledove og front-end'en.
%%       Kommunikation foregår via tekststrømme
%%     Hvad skal vores værktøj kunne, (næsten) helt præcist?
%%       Kodeeksempler
%%     For at lette udviddelsen af Turtledove vil vi prøve at holde en vis grad af modularitet
%%       API
%%       Libs
%%   Primary goals
%%   Secondary goals (nice to haves skal herunder)
%%   Limitations
%%   Learning objective
%%   Tasks and timeline


\section{Title}
``Turtledove: Tool assisted programming in SML, with special emphasis on semi-automatic rewriting to
predefined standard forms.''

\section{Motivation}
Today functional programming languages are not very widespread outside academic circles. A major
reason for this may be that not as rich development environments exists (if at all) for functional
programming languages compared to certain imperative languages (take languages in the .NET platform
as an example).

We wish to make functional programming, specifically in SML, easier to approach for the beginner as
well as more advantageous for the veteran.

Functional programming languages has a wide variety of advantages that makes them specially suited
for quick and correct statical analysis. The effect of this is that it will be possible to make more
complex tools for functional programming languages than for imperative ones.
\fixme{Er det dumt at hævde disse ting uden et opfølgende argument?}

We implement semi-automatic rewriting of terms according to a set of predefined rules. We focus on
modularity such that it will be relatively simple to implement other tools based on our software in
the future.
\fixme{Hvorfor dette værktøj? i) Vi behøver ikke regne typer, ii) vi får lov at føre nogle fine
beviser, iii) med omskrivning kan vi let implementere flere forskellige værktøjer - især hvis vi
implementerer den transitive afslutning af (dele af) omskrivningerne (tænk reduktioner).}

%% Experienced programmers will find that code complying to certain standard patterns is easier to
%% read. Another advantage of standard patterns is that compilers are able to specially optimize these,
%% possibly making such code faster.

\section{Elaboration}
We wish to be able to suggest possible rewritings to the programmer in real time, based on some
predefined rules.

This implies that our tool is initiated and responds through some user interface. There are two good
reasons why we wish to be able to develop our tool and its user interface separately:
\begin{enumerate}
\item As different programmers use different editors and generally have strong feelings
      about their choice we do not see it as an option to implement a new editor. Instead a user
      interface would be implemented on top of an existing editor. We do not wish to bind our
      tool to a single one.
\item It is not the goal of this project to implement a user interface for tool assisted
      programming.
\end{enumerate}

Since the user interface and the tool are two distinct pieces of software we have to decide a way
for them to communicate.

\subsection{Semi-automatic rewriting}
We define a set of rewriting rules:
\begin{eqnarray*}
t_0 &\rightarrow& t_0'\\
&\vdots&\\
t_n &\rightarrow& t_n'
\end{eqnarray*}

where $t_i$ and $t_i'$ are program terms and the free variables of $t_i'$ is a subset of the free
variables of $t_i$.
\\

A term $u$ is an instance of a term $t$ if and only if there exists terms $x_i$ such that
\begin{eqnarray}\label{eq:term-instance}
t[x_0 / v_0] \cdots [x_n / v_n] =_{\alpha} u
\end{eqnarray}
where $v_0, \ldots, v_n$ are the free variables of $t$.

The rule $t \rightarrow t'$ applies to $u$ with the result
\begin{eqnarray}\label{eq:term-result}
u' =_{\alpha} t'[x_0 / v_0] \cdots [x_n / v_n]
\end{eqnarray}
where the name mapping implied by the alpha equivalence of (\ref{eq:term-instance}) corresponds to
that of (\ref{eq:term-result}).

Notice that the free variables of $t'$ is a subset of $\{v_0, \ldots, v_n\}$.

\subsubsection{Rule labeling and grouping}
A large set of rewriting rules suggesting a large amount of rewritings may confuse the programmer as
to which rewritings is used in which places. Therefore we label each rule with a name and an
optional description.

Since some rules group naturally together (e.g., multiple rules for rewriting boolean expressions)
we make it possible to arrange multiple rules under a common group name.

Grouping and labeling makes it easier for the programmer to see what is going on. It could also make
it possible to turn on or off individual groups of rules or specific rules as well as computing the
transitive closure of groups of rules.

\subsubsection{Example}
Consider the following rewriting rule for a standard map form:
\begin{eqnarray}[TlcTl]
\begin{lstlisting}
fun f nil       = nil
  | f (x :: xs) = (@$\heartsuit$@) :: f xs
\end{lstlisting}
&
\
\rightarrow
\
&
\begin{lstlisting}
val f = map (fn x => (@$\heartsuit$@))
\end{lstlisting}\label{eq:rule-map}
\end{eqnarray}

Keep in mind that the \texttt{x} on the right hand side is related to the \texttt{x} on the left
as illustrated below.

The term
\begin{eqnarray}[Tl]\label{eq:term-gt}
\begin{lstlisting}
fun gt nil       = nil
  | gt (n :: ns) = n > 0 :: gt ns
\end{lstlisting}
\end{eqnarray}
is an instance of the left hand side of (\ref{eq:rule-map}) with instantiation
\begin{eqnarray*}[TlcTl]
$\heartsuit$
&
\ =\
&
\texttt{n > 0}
\end{eqnarray*}
and alpha conversion
\begin{eqnarray*}[TlcTl]
\texttt{f}
&
\ =\
&
\texttt{gt}\\
\texttt{x}
&
\ =\
&
\texttt{n}\\
\texttt{xs}
&
\ =\
&
\texttt{ns}
\end{eqnarray*}

Now using (\ref{eq:rule-map}) we get the result
\begin{eqnarray}[Tl]\label{eq:term-gt-result}
\begin{lstlisting}
val gt = map (fn n => n > 0)
\end{lstlisting}
\end{eqnarray}

\subsection{Turtledove}
Our implementation of the described tool is named Turtledove.
\\

Since we intent that Turtledove should grow to include more than one tool we design it in such a
way as to accommodate this. This means that functionality unique to a specific tool should be
separated from functionality common to most tools.

Common functionality is split between core functionality needed by every tool and a collection of
libraries that make it easier to perform common tasks.

\subsubsection{Core functionality}
The core functionality of Turtledove includes:\fixme{Tilføj ``but is not limited to''?}
\begin{enumerate}
\item Turtledove will take the path of an SML file or a project file either as a command line
  argument or through the user interface after it has been started. It then reads and parses the
  file or files contained in the project.

  The user interface should signal when a file is changed and possibly what has changed within that
  file. The one extreme is to signal a file change only when a file is saved. The other is to signal
  every key stroke. Testing will reveal the right balance.
  \fixme{For implementationsspecifikt?}

  Tools shall be signalled when the source code has changed.

\item Data is guided between the user interface and its destination. Communication is done over a
  protocol flexible enough to allow each destination to implement its own protocol.
\end{enumerate}

\section{Primary goals}

\section{Secondary goals}
\begin{itemize}
\item Flere relationer - hver relation n > 0 regler
\item Transitiv afslutning (markeres)
  - Hvorfor?
\item Ændre relationer uden at oversætte
\item Bevise semantikbevarelse for relationer
\end{itemize}


\section{Limitations}

\section{Learning objectives}

\section{Tasks and timeline}

\section{Motivation}
Today functional programming languages are not very widespread outside academic circles. A reason
for this is that not many PATs (programmer assisting tools) exist for functional programming languages
compared to certain imperative languages.

We wish to make functional programming, specifically in SML, easier to approach for the beginner as
well as more advantageous for the veteran. The means by which we hope to accomplish this task is the
development of a framework for implementing PATs, and one or more actual
tools.

Functional programming languages has a wide variety of advantages that makes them specially suited
for quick and correct statical analysis. The effect of this is that it will be possible to make more
complex tools for functional programming languages than for imperative ones.
\\

We emphasise on a single tool. Namely semi-automatic rewriting of terms to predefined standard
forms. \fixme{Hvorfor lige dette værktøj?}

\section{Elaboration}
The project can be divided into three parts.
\begin{description}
\item[Front end] The front end is responsible for communicating with the programmer. This
communication goes both ways. Some tools will work automatically, waiting for the programmer to
accept corrections and/or suggestions. Some will be initiated by the user.
\item[Back end] The back end will perform tasks common to most tools. This includes communicating
with the front end in a suitable format, reading and possibly writing project files, reading and
parsing source files, defining a representation of syntax trees, keeping an internal representation
of the source code up to date and defining auxiliary functions (e.g. functions for converting syntax
trees to source code, converting data to a format suitable for communication with the front end,
etc.).
\item[Tools] The tools will be initiated by the back end from which they will get a representation
of the source code as a syntax tree or the source code itself. Messages to the individual tools from
the front end will be delivered via the back end. The tools can send messages back to the front end
through the back end. In this project we will focus on a single tool. See section
\ref{primary_goals:a_refactoring_tool} below.
\end{description}

The back end and the tools are split up because most tools will have a lot of tasks in common as
described above.  So while the back end and the tools are actually the same piece of software, the
distinction is an important one.

The importance of this distinction implies that we develop a well-defined API for communication
between the back end and the tools.

We describe the project in greater detail in the next section.
\fixme{Denne sætning passer måske ikke så godt ind?}

\section{Primary goals}
We focus our work on the back end and a single tool. A simple front end (e.g. for Emacs) would make
testing a lot easier, but it is not a requirement for the success of this project.

As we wish to develop the back end and tool(s) separately from the front end, we choose to let all
communication between the two be through plain text.

The back end and the tool(s) compiles into a single program. We name that program and it's source
code ``Turtledove'', and we use the name interchangeably.

\subsection{Turtledove: tool assisted programming for SML} 
Turtledove will be used for two purposes; i) tool assisted programming, and ii) implementation of
new tools.

Since we intent that Turtledove should grow to include more than one tool, the protocol over which
Turtledove and a compliant front end communicate needs to be flexible enough to accommodate this.

We choose the most flexible protocol whose only feature is to guide information to and from a
specific tool. This implies that each tool will have to develop it's own protocol, and that the
front end will have to support each tool individually. We don't believe this to be a serious
limitation in practice.

Therefore we will develop a small framework for serializing (e.g. as JSON) and unserializing data as
a part of Turtledove.
\\

Turtledove will communicate with the front end through standard streams (i.e., stdin and stdout).
\\

Turtledove itself needs to be programmed in a modular way, as to make it easy to implement new tools
later. The tools shall each be confined and only interact with the rest of the program through an
API and/or the inclusion of libraries.

The API will provide the tools with functions for;
\begin{itemize}
\item retrieving (up-to-date) syntax trees and raw code. No tool should access files on it's own as
      Turtledove might track chances in files that has not yet been saved.
\item receiving data from the front end or Turtledove (e.g. ``do this'' or ``this file has changed'').
\item sending data to the front end.
\end{itemize}

The functionality of Turtledove is split between what Turtledove itself does --- the core
functionality --- and the framework that is available to programmers who write tools.
\subsubsection{Core functionality}
The core functionality is quite limited. Turtledove does two things:
\begin{enumerate}
\item Turtledove will take the path of a SML file or project file either as a command line argument
      or through the input stream after it has been started. It then reads and parses the file or
      files contained in the project. We choose SML basis files as project files.

      The front end should signal when a file is changed and possibly what has changed within that
      file. The one extreme is to signal a file change only when a file is saved. The other is to
      signal every key stroke. Testing will reveal the right balance.

      Tools shall be signalled when the source code has changed.

\item The communication between the front end and a tool is carried by Turtledove. Turtledove will
      determine the correct receiver (possibly itself) and guide data to it.

      The execution of tools will be initiated by Turtledove and done in a threaded manner. It will
      also carry data from the tools to the front end.
\end{enumerate}

\subsubsection{Framework}
Turtledove will contain a framework that helps tools perform common tasks.

This includes but is not limited to the following

\begin{description}\fixme{Skriv...}
\item[Parsing] This is crucial for the refactoring tool to.......

\item[Syntax tree representation] A way to represent syntax trees in a clever and reusable way
  that will also benefit tools to come.

\item[Pretty printing] To convert syntax tree to code

\item[Serializing] The communication bridge and protocol that links the back
  end with the front end and manages inter communication.
\end{description}

% Derudover skal der lavet en del funktionalitet som værktøjer kan bruge i form af
% biblioteker. Eksempler:
% \begin{itemize}
% \item SML-parser. Det kan f.eks. være snedigt at lagre vores ``standardformer'' som SML-kode, og så
%       indlæse det på den måde.
%
%    Hvilke "standardformer" ?
%
% \item Repræsentation af syntaxtræer.
% \item Syntaxtræ-til-kode-omformer.
% \item JSON-bibliotek, samt passende datastrukturer.
% \end{itemize}

\subsection{A refactoring tool}
\label{primary_goals:a_refactoring_tool}
Sådan som vi aftalte...

\subsection{Summary}
To summarize: the primary goals of Turtledove are
\begin{enumerate}
\item Read messages from the front end and send them to the appropriate tool or
      act directly upon them.
  
\item Send messages replies back to the front end.

\item Read and possibly write SML basis files.
\footnote{Some of the most popular SML implementations support SML basis files:
\href{http://mlton.org/}{MLton} and \href{http://www.itu.dk/research/mlkit}{MLKit} support them
directly and there is a tool that converts SML basis files to the CM files used by
\href{http://smlnj.org}{SML/NJ} automatically.}

\item Read source code and construct syntax trees.

\item Notify tools when the source code has been changed. This should be done as a minimum when
      source files are saved and preferably more often.

\item Implement a framework that help tools do common tasks.
\end{enumerate}

\section{Secondary goals}

\subsection{Project management}
Accepting changes to a project from the front end and then write those changes to the SML basis file
containing the project.

\subsection{A nice front end}
For Emacs obviously.

\section{Limitations}
\fixme{Nothing has to work as intended.}

\begin{enumerate}
\item Turtledove need not be able to read CM project files.

\item The SML parser need not handle syntax errors.

\item Changes to unsaved files need not be reflected inside Turtledove.

\item No user documentation of software will be produced (e.g., manual, user guide).
\end{enumerate}

\section{Learning objectives}

\begin{enumerate}
\item To develop structured, flexible and well-documented software for
      manipulation of source code.
\item To understand and describe source code transformations formally, and to implement such
      transformations.
\end{enumerate}

\section{Tasks and timeline}


\begin{enumerate}

\item Design an API for intercommunication between the user interface and
  Turtledove.

\item Implement a parser than can parse \textit{.mlb} project files
  \url{http://www.itu.dk/research/mlkit/index.php/ML_Basis_Files}

\item Design the structure of the concrete syntax tree and decide which approach
  and data type to implement it as.

\item Implement a parser that can parse SML code.

\item Design the term rewriting tool.

\item Implement a set of rewriting terms

\item Implement the libraries discussed in xxx. \fixme{reference to above
    needed. If this is left out of the synopsis then remove this task.}

\item Implement a project manager that given a set of file parsers (e.g., the \textit{.mlb} project file
  parser) exposes an API such that a list of names and paths can be queried from
  the file parser, for example.

\item Extend the project manager such that it at some point can implement smart
  IO handling of the source files.

\item Implement the designed API for intercommunication between the user
  interface and Turtledove.

\item Analyse Turtledove and apply threading where needed (e.g., the parser for
  SML code and Turtledove itself).

\end{enumerate}




\section{Expansion (``Nice to have'')}

\fixme{Bør dette være med i synopsis, høre det ikke mere hjemme i selve
  rapporten? Evt kunne en meget forsimplet udgave af denne liste indgå i
  synopsen i stedet}

\begin{enumerate}


\item Extend the various parsers to be incremental where applicable (e.g., the
  parser for SML source code).

\item Extend the various parsers to handle syntax errors, for example by
  skipping the source code until the next valid declaration is fount.
  The location in the skipped line of code where the first error were found
  should then be reported back to the user interface such that it can do proper
  notification to the user (e.g., underlining of erroneous code).

\fixme{this might be possible through SML-Yacc?}


\item Implement transitive closures of some of the term rewriting rules by
  adding the possibility to tag separate groups of rewriting rules that the
  transitive closures should be applied to.


\item Add a simplification group of term rewriting rules. For example the result
  of the standard map form can be simplified by the following simplification
  rule \texttt{ fn x => g x $\rightarrow$ g}


\item Extend the term rewriting definitions such that it is possible to enforce
  that a certain group of rules should always be applied to the result of applying
  another specific group of rules. For example enforcing that the simplification
  group is always applied after the standard map form rewriting rules has been applied.


\item Extend the IO file/source code handling part of the project manager to
  have a ``patch'' system such that code written in the editor is reflected
  ``live'' if the SML parser decides to parse the source files, even if the
  source files haven't been saved recently.


\item Extend Turtledove such that the SML source code parser can report back
  DocString information to the user interface which in turn can inform the user
  in an appropriate way.



\item Various parsings of the syntax tree to for example gradually remove
  syntactic sugar.
  \begin{itemize}

  \item With this a notion of ``run levels'' could be introduced, so at the end
    of each parsing all tools that hook this level will be notified and able to
    act upon this specific version of the parse tree. While the next parse of
    the syntax tree should continue if there is tools depending on one of the
    next run levels.

  \end{itemize}

\end{enumerate}

\end{document}
