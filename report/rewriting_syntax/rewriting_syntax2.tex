\documentclass[oneside]{memoir}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

\usepackage[draft]{fixme}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\usepackage{fix-cm}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{fancyvrb}
\newenvironment{code}
{\quote\Verbatim}
{\endquote\endVerbatim}

\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\codeinline}[1]{\texttt{#1}}

\chapterstyle{hangnum}

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\listoffixmes{}

\paragraph{Fixmes.} \ \\
\fixme[inline, margin=false]{Udvid normalform til at tage højde for datatyper. Specielt har vi brug
  for en funktion alá $dom$, som afgør et mønsters domæne.} \ \\

\fixme[inline, margin=false]{Indledning} \ \\

\section{Definitions}
We write concrete SML i typewriter font as this:
\begin{code}
fun id x = x
\end{code}

\begin{definition}
In the following we write $pat^\alpha$ to mean the term algebra
\[
T(con)\ \text{over}\ \alpha
\]
of the constructors of some fixed environment $E = (S\!E, T\!E, V\!E)$ (Structure
Environment, Type Environment and Value Environment) and the set of record
constructors over $\alpha$. \fixme{And the identity?}

\end{definition}

\paragraph{Note.} One can think of $pat^\alpha$ as SML-patterns generalised to
any kind of ``variables''. The constructors of datatypes are either constants or
unary functions. The record constructors form a countably infinite set of
functions with finite arity. To distinguish constructors from the surrounding
program text we write them with at initial capital letter (with very few
exceptions like \codeinline{::} \codeinline{nil}). We respect the infix status
of the symbols given by $V\!E$.

\begin{definition}[Record constructors] \ \\
  The record constructor given by
  \[
  (\alpha, \beta) \mapsto \texttt{\{foo = $\alpha$, bar = $\beta$\}}
  \]
  is denoted by $\mathfrak{R}_{\texttt{foo},\texttt{bar}}$.

  Recall that the tuple constructors are just syntactic sugar for a subset of
  the record constructors. We write $\mathfrak{T}_n$ to mean
  $\mathfrak{R}_{\texttt{1},\ldots,\texttt{n}}$.
\end{definition}

\begin{definition}[(SML) Variables] \ \\
  Is the set $var$ of all valid SML variables, which we denote by any text in
  typewriter font as with any concrete SML. For example $\mathtt{x},\
  \mathtt{y},\ \mathtt{xs}$
\end{definition}

\begin{definition}[Simple (SML) expressions]
  Is the set of $simp\_exp$ which is SML expressions without type annotation and
  infix status. \fixme[inline, margin=false]{Is this ok or shoud it be inlined down in the scheme
    body?}
\end{definition}

\begin{definition}[Meta variables] \ \\
  Is the set of $mvar \equiv \{x,\ y,\ xs,\ \ldots \}$. Meta variable range
  over $var$ and wildcards.
\end{definition}

\begin{definition}[Pattern variables] \ \\
  Is the set of $pvar \equiv \{ \overline{x},\ \overline{y},\
  \overline{xs} \}$. Pattern variables range of $pat^{var}$ .
\end{definition}

\begin{definition}[Holes] \ \\
  Is the countably infinite set, $holes$, of constants named $\diamond_1, \diamond_2,
  \ldots$, and we write $\diamond \equiv \diamond_1$.
\end{definition}

\begin{definition}[Meta patterns] \ \\
  Is the set of meta patterns $mpat \equiv \{ \mathcal{A},\ \mathcal{B},\
  \mathcal{C},\ \ldots \}$. Meta patterns range over $pat^\alpha$ for $\alpha
  \equiv pvar \cup holes$
\end{definition}

\begin{definition}[Scheme patterns]
  Is the set $spat = pat^{mpat} $
\end{definition}

\begin{definition}[Scheme bodies] \ \\
  Is the set $sbod$ which contains $simp\_exp$, the keyword \textsf{self},
  instantiated meta patterns without holes and applied transformers. 
\end{definition}

\begin{definition}[Scheme clauses] \ \\
  Is the set $clauses = spat \times sbod$. We write $|\ \alpha => \beta$ for the pair
  $(\alpha, \beta)$
\end{definition}

\begin{definition}[Schemes] \ \\
  Is the set $schemes = clauses^{+}$
\end{definition}

\begin{definition}[(Rewriting) rules] \ \\
  
\end{definition}

\begin{definition}[Transformers]
  foo
\end{definition}

\fixme{Find på bedre måde at opstille disse definitions... Evt ligesom det gamle
uden definition environments.}

\section{Problem definition}

I SML kan et mønster opfatters som et træ hvor knuderne er konstruktører og
bladende er variable. Bemærk at nulære konstruktører ikke opfattes som blade.

I det nedenstående generaliserer vi mønstre til at være parametriserede over
deres blade. Således er et SML-mønster et mønster over (SML-)variable.

Vi følger konventionen at konstanter blot opfattes som nulære konstruktører.

Vi antager at alle \texttt{as}-mønstre er fjernet. Det kan let lade sig gøre ved
substitution.

\subsection{Term definition}
\label{sec:term-definition} \fixme{find på bedre sektions navn}

\begin{description}
\item[Konkret SML:] \texttt{x :: xs}, \texttt{(a, b)}, \texttt{y}, \ldots\\
  Specielt er \texttt{x} en konkret SML-variabel.
\item[Metavariable:] $x, y, xs, \ldots$\\
  Rangerer over SML-variable og joker.
\item[Mønstervariable:] $\overline{x}, \overline{y}, \overline{xs}, \ldots$\\
  Rangerer over SML-mønstre (mønstre over SML-variable).
\item[Huller:] $\diamond_n$ er n'te "`hul"' (hole) i et meta pattern.
\item[Metamønster:] $\mathcal{A}, \mathcal{B}, \mathcal{C}, \ldots$\\
  Metamønstre er mønstre over foreningsmængden af mønstervariable og huller.
  Et metamønster kan være højereordens i den forstand at det kan indeholde et
  eller flere huller. På hullernes plads kan stå metamønstre og vi skriver
  $\mathcal{C}[\texttt{SOME } \overline{x}]$ for at indsætte metamønsteret
  $\texttt{SOME } \overline{x}$ på det første\footnote{med en passende
    definition af ``første''.} huls plads i $\mathcal{C}$.

  Et metamønster $\mathcal{A}$ er derfor et træ med (værdi-)konstruktører i
  knuderne mønstervariable, $\overline{x}$, eller huller $\diamond_n$ i bladene.

  Det konkrete SML-mønster \texttt{((a,\ b),\ x\ ::\ y\ ::\ xs)} en instans af

  \begin{tikzpicture}[]
    \node (pair)     {$(,)$};
    
    \node (X)  [below left of = pair] {$\overline{x}$};
    
    \node (cons)  [below right of = pair] {$::$};
    
    \node (Y)  [below left of = cons] {$\overline{y}$};
    \node (Z)  [below right of = cons] {$\overline{z}$};
    
    \path (pair) edge (X)
          (pair) edge (cons)
    
          (cons) edge (Y)
          (cons) edge (Z);
\end{tikzpicture}

\item[Skabelonmønstre:] \texttt{($\mathcal{C}$, $\overline{x}$)},
  \texttt{$\mathcal{C}[\overline{a}]$::$\mathcal{D}$}, \ldots\\
  Mønstre over hulfri metamønstre.

% \item[Scheme pattern] Skabelonsmønstre, defineret som $\alpha$ patterns med
%   $\alpha$ værende meta patterns. Kan omtales patterns over meta patterns.

%   Hvis skabelons mønstre blot var meta patterns ville vi kunne udtrykket mønstre
%   som $(\overline{x}, \overline{y})$ eller $\mathcal{C}[\overline{x} ::
%   \overline{xs}]$ men der ville ikke kunne udtrykkes mønstre som $(\overline{x},
%   \mathcal{C}[\overline{y} :: \overline{ys}])$ da bladene i meta patterns kun
%   kan være patvars eller huller.

%   Ved at skabelons mønstre er patterns over meta patterns får vi mere
%   udtrykskraft og kan derfor udtrykke førnævnte mønster $(\overline{x},
%   \mathcal{C}[\overline{y} :: \overline{ys}])$

\item[Transformere:] % M for Megatron, O' for Optimus Prime
  $\mathbb{M}_{\textnormal{\fontsize{2}{3pt}\selectfont egatron}}, \mathbb{O}',
  \mathbb{D}, \ldots$\\
  Er metafunktioner som tager nøjagtigt et SML-mønster og returnerer
  et SML-udtryk. \fixme{At some point define how the magic works.}

\item[Skabelonkroppe:]
  SML-udtryk uden typeannotering og infix-operatorer, med tilføjelse af
  nøgleordet \textsf{self} samt (instantierede) hulfri metamønstre og (anvendte)
  transformatorer.

% \item[Scheme body] SML udtryk uden type annotering, infix operatorer, Og
%   \texttt{self}, meta patterns og transformers.


\item[Skabelon] | $schemepat => schemebody$ \ldots\\
  Er en liste af par af skabelonmønstre og skabelonkroppe adskilt af $=>$. Et
  konkret stykke SML-kode kan være en instans af en skabelon, hvorved
  metamønstrene instantieres. Mønstervariable i skabelonmønstre instantieres per
  klausul. Dette og muligheden for forekomster af huller er den eneste forskel
  på metamønstre og mønstervariable.

\item[Omskrivningsregel:]
  En omskrivningsregel har en venstreside som er en skabelon og en højreside som
  er et konkret stykke SML-kode. I højresiden kan bruges instantierede
  metamønstre og transformere fra venstresiden.

\item[Kanoniske afbildning af SML-mønstre til SML-udtryk] betegnes $\kappa$.

\item[Kanonisk instantiering:] $\floor{\mathcal{C}}$ er den kanoniske
  instantiering af et metamønster. Alle mønstervariable i det givne metamønster bliver
  instantieret til konkrete SML-variabel med hensyntagen til capture
  avoidance\fixme{hvad hedder capture avoidance på dansk}.

  Dette bruges i resultatet af en skabelon, da mønstervariable her ikke er
  bundet til et ML-mønster.

  Eksempel $\floor{\mathcal{C}}$ $\mathcal{C} = \texttt{(}\diamond\texttt{,} \overline{y}\texttt{)}$:
  $\floor{\mathcal{C}} = \floor{\texttt{(}\diamond\texttt{,} \overline{y}\texttt{)}} = \texttt{(}\diamond\texttt{,}
  \floor{\overline{y}}\texttt{)} = \texttt{(}\diamond\texttt{,} \texttt{a)}$.
 
\end{description}

Når mønstervariable ($\overline{x}$) bruges i højresiden af en skabelonklausul
(skabelonkrop) bliver de implicit erstattet med det ML mønster de er bundet
til fra venstresiden (skabelons mønsteret), se nedenstående eksempel

\begin{example}[Matching/brug af mønstervariable] \

  \fixme{Find ordenligt eksempel navn/tekst}
  
  Betragt ML-funktionen \texttt{foo}:

\begin{verbatim}
fun foo (a, b :: xs) = b + a
  | foo _            = 0
\end{verbatim}

  Den første klausul er en instans af skabelonklausulen
  \[
  \mathcal{C}[\overline{x}\texttt{ :: }\overline{xs}] =>
  \mathbb{D}(\mathcal{C}[\overline{x}])
  \]

  med
  \begin{align}
    \mathcal{C} &\mapsto \texttt{(}\overline{y}\texttt{,} \diamond\texttt{)}\\
    \overline{a} &\mapsto \texttt{a}\\
    \overline{x} &\mapsto \texttt{b}\\
    \overline{xs} &\mapsto \texttt{xs}\\
    \mathbb{D}(\texttt{(}\overline{a}\texttt{,} \overline{b}\texttt{)}) &=
    \kappa(\overline{b}) \texttt{ + } \kappa(\overline{a})
  \end{align}

  Den anden klausul er en instans af skabelonklausulen
  \[
  \mathcal{D} => \mathbb{E}(\mathcal{D})
  \]

  med
  \begin{align}
    \mathcal{D} &\mapsto \overline{a}\\
    \overline{a} &\mapsto \texttt{\_}\\
    \mathbb{E}(\overline{a}) &= \texttt{0}
  \end{align}

  Hvis vi nu er så heldige (og det er vi her) at $dom(\lfloor\mathcal{D}\rfloor)
  = dom(\lfloor\mathcal{C[\texttt{\_}]}\rfloor)$ har vi en instans af
  $\textsf{map}$. Resultatet er
  \begin{align}
    &\texttt{fun foo $\lfloor \mathcal{C} \rfloor [\lfloor xs \rfloor]$ = map (fn $x$ =>
      $\mathbb{D}(\lfloor \mathcal{C} \rfloor[\lfloor x \rfloor])$) $\lfloor xs
      \rfloor$} =\\
    &\texttt{fun foo (a, b) = map (fn b => b + a) b}
  \end{align}

  Vi har her skrevet den kanoniske instantiering eksplicit, men i resten af
  dokumentet lader vi den være underforstået. Instantieringer kan jo kun
  forekomme i omskrivningsreglers højresider, hvor de i øvrigt ikke kan
  undværes.
\end{example}


\subsection{Skabeloner}

En skabelon defineres kun ud fra de klausuler som den skal matche. Altså
bruges der ikke syntaks til at matche funktionsnavnet. For at kunne matche
rekursive funktioner introducerer vi nøgleordet \textsf{self} som er en
pladsholder for funktionsnavnet af den funktion der bliver matchet mod
skabelonen.

\fixme{Her kommer normalformen på noget af en opgave, men det ser ud til at
  virke. Tjek det!}

Skabeloner kan matche partielt i den forstand at hvis klausulerne $n$ til $n +
i$ er en instans af en regel med $i$ skabelonklausuler, så kan omskrivningen
udføres for blot disse klausuler.

Ved ikke at udtrykke mere information om funktionen eller dens parametre kan vi
have samme skabelonsyntaks for sekventialiserede og ikke-sekventialiserede
funktionserklæringer.

Det huskes at den sekventialiserede funktion

\begin{verbatim}
fun add n nil       = nil
  | add n (x :: xs) = n + x :: add n xs
\end{verbatim}

skrives om (i flere trin) til

\begin{verbatim}
val rec add = fn n => 
              fn xs => (fn (n, nil) => nil
                         | (n, x::xs) => n + x :: add n xs) (n, xs)
\end{verbatim}

Og samme funktion på ikke-sekventialiseret form

\begin{verbatim}
fun add' (n, nil)     = nil
  | add' (n, x :: Xs) = n + x :: add' (n, xs)
\end{verbatim}

bliver skrevet om til

\begin{verbatim}
val rec add' = fn (n, nil) = []
                | (n, x::xs) = n + x :: add' (n, xs)
\end{verbatim}

Som det ses ender begge tilfælde her med en enkelt anonym funktion (kun den inderste
har interesse hvis der skulle være flere). Hvis den oprindelige funktion var på
sekventialiseret form bliver alle argumenterne sat sammen til en tupel og hvis
den var på ikke sekventialiseret form så var argumentet allerede en tupel.

Denne inderste anonyme funktion har derfor nu et antal klausuler og hvor hvert
klausuls mønster og krop matcher det der var givet i den oprindelige
funktion.

Vi har valgt at definere vores skabeloner på en sådan måde at de minder meget om
ovenstående. Alle klausuler i en skabelon starter på $|$ (hvilket på nær den
første også altid er tilfælde for ML). Da vi ønsker at abstrahere den konkrete
erklæring væk (\texttt{val} \texttt{fun}, sekventialiseret,
ikke-sekventialiseret) starter alle vores klausuler på $|$.

Vi mener dette tilstræber den mest naturlige måde at udtrykke skabeloner der
matcher ML kode.

Skabeloner defineres altså som en liste af $n$ klausuler

\begin{eqnarray*}[rqrl]
| & m_1 & => e_1 \\
  &  & \vdots \\
| & m_n & => e_n
\end{eqnarray*}

hvor $m_k$ er skabelonmønstre og $e_k$ er skabelonkroppe.

\fixme{Der beskrives slet ikke hvordan og hvorledes med resultat
  omskrivningen. Der beskrives kun den matchende del af skabelonen.}

\subsubsection{Restriktioner, prædikater og metafunktioner}
\textit{Here be løse tanker}\\

Vi udtrykker restriktioner på en skabelon med nøgleordet \textsf{where}
efterfulgt af restriktionerne.

Som vi så i eksemplet ovenfor kan det blive nødvendigt at indføre restriktioner
på nogle metamønstre som funktion af andre. Vi ved at vi har brug for noget alá
$dom$. Måske skal vi bruge andre ting.

Prædikater og funktioner på udtryk (og ved udvidelse på metafunktioner) kan også
blive nødvendige. Specielt kan det tænkes at et prædikat som afgør om et udtryk
har sideeffekter eller ej bliver nødvendigt.

Metafunktionerne implementeres nok kønnest ``uden for''
omskrivningssystemet. F.eks. omformes erklæringer til normalform før de
forsøges omskrevet, og man kunne forestille sig et forsimplingstrin
efterfølgende (eta-reduktion vil være ret nyttigt). Andre ting som
\texttt{let}-løftning bør også overvejes.

Bemærk at metafunktionerne kan have en nytteværdi i sig selv, og ikke blot
sammen med omskrivningssystemet.


\subsection{Maching af skabeloner}

% \fixme{bedre titel næste gang...}

% Der kræves 4 skridt for at verificere om en funktion matcher en skabelon

% \begin{enumerate}
% \item Antal klausuler stemmer overens i skabelon og funktion der skal matche.

% \item Hver klausuls krop fra skabelonen kan ``matches'' med den tilsvarende
%   klausuls krop i funktion.

% \item $\mathcal{C}[patvar_1]\ldots[patvar_n]$ fra regel $m$ skal matche den
%   oprindelige funktions pattern $m$, hvor samtlige $patvar_k$ skal kunne matche
%   et deltræ af det oprindelige pattern. Alle disse matchede deltræer må ikke
%   overlappe og de vil blive erstattet med $diamond_k$ og $patvar_k$ bliver
%   bundet til det deltræ den matchede.

Det er en af vores pointer at systemet selv skal finde passende
metamønstre. Nogle gange giver en skabelonklausul anledning til flere
mulige metamønstre. I de fald må resten af omskrivningsreglen slå fast hvilket
der er rigtigt (om noget).

Her er eksempler på mønstre og de metamønstre de resulterer i.

Vi regner med at en blindgydesøgning i praksis vil være hurtig nok.

  \begin{example} \ 

    % \fixme{Burde nok medtage hvad parvars bliver bundet til også.}

    \begin{tabular}{l|l|l} 
      ML-mønster & Skabelonmønster & Resulterende
      $\mathcal{C}$ \\ \hline
      
      \texttt{(a, b) :: xs} & $\mathcal{C}[\overline{x} \texttt{ :: } \overline{xs}]$ &
      $\diamond$ \\

      \texttt{(b, a) :: xs} & $\mathcal{C}[\overline{x} \texttt{ :: } \overline{xs}]$ &
      $\diamond$ \\

      \texttt{(a, x :: xs)} & $\mathcal{C}[\overline{x} \texttt{ :: } \overline{xs}]$ &
      $(\overline{a}, \diamond)$ \\

      \texttt{(x :: xs, b)} & $\mathcal{C}[\overline{x} \texttt{ :: } \overline{xs}]$ &
      $(\diamond, \overline{b})$ \\

      \texttt{(x :: xs, y :: ys)} & $\mathcal{C}[\overline{x} \texttt{ :: }
      \overline{xs}][\overline{y} \texttt{ :: } \overline{ys}]$ &
      $(\diamond_1, \diamond_2)$ eller $(\diamond_2, \diamond_1)$\\
      
    \end{tabular}
    
  \end{example}

% \item $\mathbb{D}$ genererer en funktion der sender det resulterende $pat$ hen i
%   en $exp$ hvor $exp$ netop er den $exp$ der matcher funktionens $exp$ på
%   pågældende plads.

% \end{enumerate}

\subsection{Prædefinerede skabeloner}


Nedenfor gives forskellige skabeloner for omskrivning til nogle af de mest
almindelige ML udtryk.

\begin{definition}[Omskrivning af \textsf{map}-instanser]
  % Bemærk at omkskrivningen til normalform garanterer at mønsteret i den anden
  % klausul er joker.

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}  [\overline{x} \texttt{ :: } \overline{xs}] &  => \mathbb{D}
    (\mathcal{C}[ \overline{x}]) \texttt{ :: } \textsf{self}(\kappa ( \mathcal{C}
    [ \overline{xs} ] ) ) \\
    | & \mathcal{D} & => \texttt{nil}\\
    & \textsf{where}\ \ & dom(\mathcal{D}) = dom(\mathcal{C}[\texttt{\_}])\\
   \tabpause{\begin{center}$\Downarrow$\end{center}}
    | & \mathcal{C} [ xs ] & => \texttt{map (fn $m$ => $\mathbb{D}(\mathcal{C} [ m ]$ )) $xs$}
  \end{eqnarray*}
\end{definition}

\begin{definition}[Omskrivning af \textsf{foldl}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}[\overline{x} \texttt{ :: } \overline{xs}] &  => \mathbb{D} ( \texttt{($\mathcal{C}
      [\overline{x}]$, $\textsf{self}( \mathcal{C}[\overline{xs}])$)} ) \\
    | & \mathcal{D} & => \mathbb{E}(\mathcal{D})\\
    & \textsf{where}\ \ & dom(\mathcal{D}) = dom(\mathcal{C}[\texttt{\_}])\\
    \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \mathcal{C} [xs] & => \texttt{foldl (fn ($a$, $b$) => $\mathbb{D}($($\mathcal{C}[a]$, $b$)$)$) $\mathbb{E}(\mathcal{C}[\texttt{nil}])$ $xs$}
  \end{eqnarray*}

  
\end{definition}


\chapter{Rewriting syntax}

$\{ \ldots \}$ means zero or more occurances.
$+$ means 1 or more occurances.

When specifying rewriting rules we 

\setlength{\grammarindent}{7.3em}
\begin{grammar} 
 
  <upper-letter> = "[A-Z]" \hfill "# Regex, big letter"

  <lower-letter> = "[a-z]" \hfill "# Regex, small letter"

  <ws> = "\\s" \hfill "\# Regex, all whitespace"

  <letter> ::= <upper-letter> | <lower-letter>

  <rules> ::= <rule> | <rule> <rules>

  <rule> ::= "rule" <rule-type> <rule-name> \\
             \hspace*{1em} <clauses> \\
             <opt-where> \hfill "\# is optional" \\
             "becomes" \\
             \hspace*{1em} <clauses> \\
             "end"

  <rule-type> ::= "clauses" | "expression" 

  <rule-name> ::= <letter>+ \hfill "\# No spaces allowed in rule-names"

  <clauses> ::= <clause>+

  <clause> ::= "|" <spat> "=>" <sexps>

  <opt-where> ::= something with the dom....

  <spat> ::= <sml-identifier> | <meta-pattern>

  <sexps>  ::= <sexp>+
  
  <sexp>   ::= <sml-identifier> | <meta-pattern> | <transformer>

  <transformer> ::= "{" <upper-letter> "}" "(" <meta-pattern> ")" \hfill "\# Fix the input"

  <meta-pattern> ::= "§" <upper-letter> \{ <opt-meta-pattern-input> \}

  <opt-meta-pattern-input> ::= "[" <meta-pattern> "]" \hfill "\# Fix the input"

\end{grammar}

\fixme{Needs an owehaul}

Følgende eksempler definerer forskellige varianter af funktionen $\texttt{foo}$
som implementerer forskellige varianter af SML's $\texttt{map}$ funktion.

\begin{example}[\textsf{map}-instans]\
\begin{verbatim}
fun foo (nil, f)     = nil
  | foo ([x], g)     = [g x]
  | foo (x :: xs, f) = f x :: foo (xs, f)
\end{verbatim}

bliver normaliseret til

\begin{verbatim}
fun foo ([x], g)     = [g x]
  | foo (x :: xs, f) = f x :: foo (xs, f)
  | foo _            = nil
\end{verbatim}

De to sidste to klausuler er en instans af \textsf{map}-reglen med
\begin{align}
\mathcal{C} &\mapsto \texttt{($\diamond$, $\overline{y}$)}\\
\overline{x} &\mapsto \texttt{x}\\
\overline{xs} &\mapsto \texttt{xs}\\
\mathbb{D}(\texttt{($\overline{a}$, $\overline{b}$)}) &= \kappa(\overline{b})\
\kappa(\overline{a})\\
\mathcal{D} &\mapsto \texttt{\_}
\end{align}

Så de skrives om til
  \begin{align}
    &\texttt{$\mathcal{C}[xs]$ => map (fn $m$ =>
      $\mathbb{D}(\mathcal{C}[m])$) $xs$} =\\
    &\texttt{(a, b) => map (fn a => b a) a}
  \end{align}

Og det endelige resultat er

\begin{verbatim}
fun foo ([x], g) = [g x]
  | foo (a, b)   = map (fn a => b a) a
\end{verbatim}

\end{example}

\begin{example}[\textsf{map}-instans]\
\begin{verbatim}
fun foo nil       = nil
  | foo (x :: xs) = x + 1 :: foo xs
\end{verbatim}

bliver normaliseret til

\begin{verbatim}
fun foo (x :: xs) = x + 1 :: foo xs
  | foo _         = nil
\end{verbatim}

Resultatet bliver

\begin{verbatim}
fun foo a = map (fn a => a + 1) a
\end{verbatim}


% \begin{eqnarray*}
%     (\mathsf{nil}) &=>& \mathsf{nil} \\
%     (x::xs) &=>& x+1 :: \mathsf{foo} xs
%   \end{eqnarray*}
  
%   Bliver normaliseret til 

%   \begin{eqnarray*}
%     (x::xs) &=>& x+1 :: \mathsf{foo} xs \\
%     x &=>& \mathsf{nil}
%   \end{eqnarray*}

%   \begin{enumerate}
%   \item Antal klausuler matcher.
    
%   \item Funktions kroppe kan matche med tilsvarende klausuls kroppe.
    
%   \item $\mathcal{C}$ instantieres til $\diamond$
    
%     \begin{description}
%     \item[Klausul 1] 
%       \begin{itemize}
%       \item På venstresiden bindes $\overline{x} \mapsto x, \overline{xs} \mapsto xs$.
        
%       \item På højresiden fås derfor $\mathcal{C}[\overline{x}] = x$ og
%         $\mathcal{C}[\overline{xs}] = xs$        
%       \end{itemize}
        
      
%     \item[Klausul 2]
%       \begin{itemize}
%       \item På venstresiden bindes $\overline{x} \mapsto
%         x$.
        
%       \item På højresiden er der ikke brugt nogle patvars så der sker ikke
%         noget.
%       \end{itemize}
      
%     \end{description}
      
%   \item $\mathbb{D}$ genererer funktionen der for input
%     $\mathcal{C}[\overline{x}] = x$ returnerer $x + 1$ da dette er udtrykket i
%     funktionen som matcher $\mathbb{D}\left( \mathcal{C}[\overline{x}] \right)$
%     i skabelonen. Altså $\mathbb{D}(\overline{x}) = \kappa(\overline{x}) + 1$ 
%   \end{enumerate}

%   Vi har altså nu at funktionen matcher skabelonen og derfor kan omskrives til
%   følgende ud fra skabelonenes omskrivning regel

%   \begin{eqnarray*}[c]
%       \mathcal{C}|[\mathcal{X\!S}|] => \textsf{map } \left( \textsf{fn } m =>
%     \mathbf{D}\left( \mathcal{C}|[m|] \right) \right) \mathcal{X\!S} \\
%   %
%   \Downarrow \\
%   %
%   xs => \textsf{map } \left( \textsf{fn } m =>
%     \left( \textsf{fn } x => x + 1 \right) m \right) xs \\
%   \end{eqnarray*}

\end{example}


% \begin{example}
%   \begin{eqnarray*}
%     (nil, \_) &=>& nil\\
%     (x::xs, n) &=>& F\ (x * n) :: \mathsf{foo} (xs, n)\\
%   \end{eqnarray*}
% \end{example}

\section{Map}

\begin{example}[\textsf{fold}-instans]\
\begin{verbatim}
fun sum nil       = 0
  | sum (x :: xs) = sum xs + x
\end{verbatim}

normaliseres til

\begin{verbatim}
fun sum (x :: xs) = sum xs + x
  | sum _         = 0
\end{verbatim}

De to klausuler er en instans af \textsf{foldl}-reglen med

\begin{align}
  \mathcal{C} &\mapsto \diamond\\
  \overline{x} &\mapsto \texttt{x}\\
  \overline{xs} &\mapsto \texttt{xs}\\
  \mathbb{D}(\texttt{($\overline{a}$, $\overline{b}$)}) &=
  \kappa(\overline{b}) \texttt{ + } \kappa(\overline{a})\\
  \mathcal{D} &\mapsto \texttt{\_}\\
  \mathbb{E}(\overline{a}) &= \texttt{0}
\end{align}

Så de skrives om til
  \begin{align}
    &\texttt{$\mathcal{C}[xs]$ => foldl (fn ($a$, $b$) =>
      $\mathbb{D}($($\mathcal{C}[a]$, $b$)$)$) $\mathbb{E}(\mathcal{C}[$nil$])$ $xs$} =\\
    &\texttt{a => foldl (fn (a, b) => b + a) 0 a}
  \end{align}

Og det endelige resultat er

\begin{verbatim}
fun sum a = foldl (fn (a, b) => b + a) 0 a
\end{verbatim}


  % \begin{eqnarray*}
  %   (y::ys) &=>& y + \mathtt{self} \left( ys \right) \\
  %   nil &=>& 0
  % \end{eqnarray*}

  % Hvilket er normaliseret så det bliver ikke omskrevet.

  % \begin{enumerate}
  % \item Antal klausuler matcher.

  % \item 

  % \item $\mathcal{C}$ instantieres til $\diamond$ og $\mathcal{G} = 0$

  %   \begin{description}
  %   \item[Klausul 1] $\overline{x} \mapsto y, \overline{xs} \mapsto ys$
      
  %   \item[Klausul 2] $\overline{x} \mapsto nil$
  %   \end{description}
    
    
  % \item $\mathbb{D}(\overline{n}, \overline{m}) = \kappa(\overline{n}) +
  %   \kappa(\overline{m})$
  % \end{enumerate}

  % Vi kan derfor anvende denne skabelon og lave omskrivningen, hvor der haves
  % $\floor{\mathcal{C}} = \diamond, \floor{\mathcal{G}} = 0$

  % \begin{eqnarray*}[c]
  %    \floor{\mathcal{C}} [xs]  => \textsf{fold } \left( \textsf{fn } (a,b) =>
  %     \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \
  %   \floor{\mathcal{G}} \ xs \\
  %   %
  %   \Downarrow \\
  %   % 
  %   xs => \textsf{fold } \left( \textsf{fn } (a,b) => a+b
  %   \right) \ 0 \ xs
  % \end{eqnarray*}
  
\end{example}

\appendix

\chapter{Sample rewriting rules}

\section{Map}





\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
