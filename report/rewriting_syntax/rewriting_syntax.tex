\documentclass[oneside]{memoir}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

\usepackage[draft]{fixme}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}


\chapterstyle{hangnum}

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\section{Problem definition}


%I nedenstående vil $\mathit{x}, \mathit{foo}$ betyde meta variable som kan
instantieres til SML identifiers og $\diamond_n$ er n'te ``hul''.


% \begin{description}
% \item[Contekst] På venstresiden matches alle $pat_x$ til $\diamond_x$ for $x \in
%   {1,\ldots, n}$. Og på højresiden indsættes $pat_y$ i stedet for $\diamond_y$
%   for $y \in {1, \ldots, n}$.
% \item[Transform] Konstruerer magisk et udtryk ud fra et pattern. Resulterende
%   $exp$ må ikke binde variable fra $\diamond_n$ (Capture Avoidance).
% \end{description}

Explain the \texttt{self} keyword (curry virker bare).

For $\kappa$ værende den kanoniske afbildning af $pat -> exp$ defineret i
miniml.

Definer $\floor{...}$ (Kanonisk metamønster instantiering.

Definer $\floor{\mathcal{C}}$. Eks. $\mathcal{C} = (\diamond, \overline{y})$:
$\floor{\mathcal{C}} = \floor{(\diamond, \overline{y})} = (\diamond,
\floor{\overline{y}}) = (\diamond, a)$.

Forklar hvordan $\overline{x}$ implicit skal erstattes med dets bundne pattern når
de bruges på højresiden, så $foo((a,b)::xs) = b+a$ for reglen $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(\mathcal{C}[\overline{x}])$ hvor på venstresiden
bliver følgende bundet $\overline{x} \mapsto (a,b), \overline{xs} \mapsto xs$ så
på højresiden bliver $\overline{x}$ erstattet med $(a,b)$ og der haves $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(\mathcal{C}[(a,b)])$ hvor
$\mathcal{C} = \diamond$, så der kan yderligere reduceres til $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(a,b)$ hvor $\mathbb{D}$ gør det
forventede og producere $b+a$. ~~~~~~~~~~~~ WUB WUB

Nedenfor er skabeloner for matchende funktioner:

\begin{definition}[Omskrivning af \texttt{map}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}  [\overline{x} :: \overline{xs}] &  => \mathbb{D}
    (\mathcal{C}[ \overline{x}]) :: \mathtt{self}(\kappa \mathsf{(} \mathcal{C} 
    [ \overline{xs} ] \mathsf{) )} \\
    | & \overline{x} & => \mathsf{nil} \\
   \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [ xs ] & => \textsf{map } \left( \textsf{fn } m =>
      \mathbb{D}\left( \floor{\mathcal{C}} [ m ] \right) \right) \ xs
  \end{eqnarray*}
\end{definition}

\begin{definition}[Omskrivning af \texttt{fold}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}[\overline{x} :: \overline{xs}] &  => \mathbb{D} \left( \mathcal{C}
      [\overline{x}],\ \mathtt{self} \left( \mathcal{C}[\overline{xs}] \right) \right) \\
    | & \overline{x} & => \mathcal{G} \\
    \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [xs] & => \textsf{fold } \left( \textsf{fn } (a,b) =>
      \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \ \floor{\mathcal{G}} \ xs
  \end{eqnarray*}
  
  
\end{definition}


% D (\bar{x}, \bar{y}) = \kappa(\bar{x}) + \kappa(\bar{y})

Der kræves 4 skridt for at verificere om en funktion matcher en skabelon

\begin{enumerate}
\item Antal klausuler stemmer overens i skabelon og funktion der skal matche.

\item Hver klausuls krop fra skabelonen kan ``matches'' med den tilsvarende
  klausuls krop i funktion.

\item $\mathcal{C}[patvar_1]\ldots[patvar_n]$ fra regel $m$ skal matche den
  oprindelige funktions pattern $m$, hvor samtlige $patvar_k$ skal kunne matche
  et deltræ af det oprindelige pattern. Alle disse matchede deltræer må ikke
  overlappe og de vil blive erstattet med $diamond_k$ og $patvar_k$ bliver
  bundet til det deltræ den matchede.

  Eks:
  ML Funktions pattern | Skabelon definition | Resulterende $\mathcal{C}$

     (a,b)::xs         | 


\item $\mathbb{D}$ genererer en funktion der sender det resulterende $pat$ hen i
  en $exp$ hvor $exp$ netop er den $exp$ der matcher funktionens $exp$ på
  pågældende plads.

\end{enumerate}

\section{Eksempler}

Følgende eksempler definerer forskellige varianter af funktionen $\mathsf{foo}$
som implementerer forskellige varianter af SML's $\mathsf{map}$ funktion.

\begin{example}[\texttt{map}-instans]
  \begin{eqnarray*}
    (\mathsf{nil}, f) &=>& \mathsf{nil} \\
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f)
  \end{eqnarray*}

  vil den blive normaliseret til
  \begin{eqnarray*}
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f) \\
    \_ &=>& nil
  \end{eqnarray*}

  Da $\mathsf{nil}$ er mest generel, efterfulgt af $x::xs$ og $[x]$. $(\mathsf{nil}, f)$
  bliver erstattet af en bundstreg af generaliseringen da ingen af argumenterne
  bliver brugt på højresiden (bemærk at på højresiden $\mathsf{nil}$ er en
  konstruktør og derfor ikke er bundet til $\mathsf{nil}$ på venstresiden).

  Ovenstående eksempel vil have konteksterne $\mathcal{C} = (\diamond, ),
  \mathcal{D} = f$

  Ved unificering vil man hurtigt kunne fastslå at første klausul er unødvendig
  (kræver 1 $\beta$-reduktion af $\mathsf{foo}$ i andet klausul). Hvis denne
  unificering ikke udføres vil dette eksempel ikke kunne fanges af den
  definerede regel:

  \begin{enumerate}
  \item Antal klausuler passer ikke, funktionen kan ikke matche skabelonen.
  \end{enumerate}
\end{example}



\begin{example}[\texttt{map}-instans]
  \begin{eqnarray*}
    (\mathsf{nil}) &=>& \mathsf{nil} \\
    (x::xs) &=>& x+1 :: \mathsf{foo} xs
  \end{eqnarray*}

  Bliver normaliseret til 
  \begin{eqnarray*}
    (x::xs) &=>& x+1 :: \mathsf{foo} xs \\
    x &=>& \mathsf{nil}
  \end{eqnarray*}

  \begin{enumerate}
  \item Antal klausuler matcher.

  \item Funktions kroppe kan matche med tilsvarende klausuls kroppe.

  
  \item 
    \begin{description}
    \item[Klausul 1] $\mathcal{C}$ instantieres til $(x::xs)$.
      \begin{itemize}
      \item $\mathcal{C}|[\mathcal{X}::\mathcal{X\!S}|]$ på venstresiden
        erstatter $x::xs$ i $\mathcal{C}$ til $\diamond_1$ da $pat_1 =
        \mathcal{X}::\mathcal{X\!S}$ i venstresidens
        $\mathcal{C}|[pat_1|]\ldots|[pat_n|]$. Heraf bindes $\mathcal{X} \mapsto
        x, \mathcal{X\!S} \mapsto xs$. Der haves derfor nu at $\mathcal{C} =
        \diamond_1$

      \item På højresiden fås derfor $\mathcal{C}|[\mathcal{X}|] = x$ og
        $\mathcal{C}|[\mathcal{X\!S}|] = xs$ ved substitution af $pat_n$ i
        $\mathcal{C}|[pat_1|]\ldots|[pat_n|]$ for $\diamond_n$ i $\mathcal{C}$.
      \end{itemize}
      

    \item[Klausul 2] $\mathcal{C}$ instantieres til $x$ (kunne også have været
      $\_$ (wildcard).
      \begin{itemize}
      \item Trivielt/uinteressant. \fixme{do it...}
      \end{itemize}

    \end{description}

  \item $\mathbb{D}$ genererer funktionen der for input
    $\mathcal{C}|[\mathcal{X}|] = x$ returnerer $x + 1$ da dette er udtrykket i
    funktionene som matcher $\mathbb{D}\left( \mathcal{C}|[\mathcal{X}|]
    \right)$ i skabelonen. Altså $\mathbb{D}(x) = x + 1$ eller skrevet som som
    SML funktion $\mathbb{D} = \textsf{fn } x => x + 1$ og $\mathbb{D}\left(
      \mathcal{C}|[\mathcal{X}|] \right) = \left( \textsf{fn } x => x + 1
    \right) \left( \mathcal{C}|[\mathcal{X}|] \right) $.
  \end{enumerate}

  Vi har altså nu at funktionen matcher skabelonen og derfor kan omskrives til
  følgende ud fra omskrivnings definitionen og de bundne meta variable defineret
  ovenfor

  \begin{eqnarray*}[c]
      \mathcal{C}|[\mathcal{X\!S}|] => \textsf{map } \left( \textsf{fn } m =>
    \mathbf{D}\left( \mathcal{C}|[m|] \right) \right) \mathcal{X\!S} \\
  %
  \Downarrow \\
  %
  xs => \textsf{map } \left( \textsf{fn } m =>
    \left( \textsf{fn } x => x + 1 \right) m \right) xs \\
  \end{eqnarray*}

\end{example}


\begin{example}
  \begin{eqnarray*}
    (nil, \_) &=>& nil\\
    (x::xs, n) &=>& F\ (x * n) :: \mathsf{foo} (xs, n)\\
  \end{eqnarray*}
\end{example}

\begin{example}[\texttt{fold}-instans]

  \begin{eqnarray*}
    (y::ys) &=>& y + \mathtt{self} \left( ys \right) \\
    nil &=>& 0
  \end{eqnarray*}

  Hvilket er normaliseret så det bliver ikke omskrevet.

  Følgende bliver instantieret

  $\mathcal{C} = \diamond, \mathcal{G} = 0, \mathbb{D}(\overline{n},
  \overline{m}) = \kappa(\overline{n}) + \kappa(\overline{m}),
  \floor{\mathcal{C}} = \diamond, \floor{\mathcal{G}} = 0$.

  

  \begin{description}
    \item[Klausul 1] $\overline{x} = y, \overline{xs} = ys$

    \item[Klausul 2] $\overline{x} = nil$
  \end{description}

  \begin{eqnarray*}
    xs &=>& \textsf{fold } \left( \textsf{fn } (a,b) => \mathbb{D}(a,b)
    \right) \ \mathcal{G} \ xs
  \end{eqnarray*}
  
\end{example}



\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
