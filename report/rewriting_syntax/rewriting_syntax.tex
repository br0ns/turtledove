\documentclass[oneside]{memoir}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

\usepackage[draft]{fixme}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\usepackage{fix-cm}

\usepackage{tikz}

\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}


\chapterstyle{hangnum}

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\section{Problem definition}





I nedenstående vil $\alpha$ patterns vil være træer af konstruktører som knuder og $\alpha$ som
blade, hvor tal (SML special consts) opfattes som nulære konstruktører af
simplificerende grunde og har derfor ingen blade.

\subsection{Term definition}
\label{sec:term-definition} \fixme{find på bedre sektions navn}

\begin{description}
\item[Patvar] $\overline{x}, \overline{y}, \overline{xs}$ er mønster variable
  (pattern variables) over ML mønstre.


\item[Hole] $\diamond_n$ er n'te "`hul"' (hole) i et meta pattern.


\item[ML pattern] $x,y,z$ er ML mønstre (ML patterns), defineret som $\alpha$ patterns med
  $\alpha$ værende .....  \fixme{Hvordan passer det ind i vores definition af
    patterns?}


\item[Meta pattern] $\mathcal{A}, \mathcal{B}, \mathcal{C}$ er meta mønstre
  (meta patterns), defineret som $\alpha$ patterns hvor $\alpha$ kan være
  patvars eller huller. Hvis der kun er et hul i et meta pattern vil hullet være
  implicit annoteret med $n=1$.

  Et meta pattern $\mathcal{X}$ er derfor et træ kun bestående af konstruktører
  som knuder og pattern variable $\overline{x}$ eller huller $diamond_n$ som
  blade.

  I nedenstående er $((a,\ b),\ x\ ::\ y\ ::\ xs)$ en instans af $\mathcal{X}$

  \begin{tikzpicture}[]
    
    \node (pair)     {$(,)$};
    
    \node (X)  [below left of = pair] {$\overline{x}$};
    
    \node (cons)  [below right of = pair] {$::$};
    
    \node (Y)  [below left of = cons] {$\overline{y}$};
    \node (Z)  [below right of = cons] {$\overline{z}$};
    
    \path (pair) edge (X)
          (pair) edge (cons)
    
          (cons) edge (Y)
          (cons) edge (Z);
    
\end{tikzpicture}

\fixme{Forklar omkring "`argumenterne"' til et meta pattern.}
  

\item[Scheme pattern] Skabelonsmønstre, defineret som $\alpha$ patterns med
  $\alpha$ værende meta patterns. Kan omtales patterns over meta patterns.

  Hvis skabelons mønstre blot var meta patterns ville vi kunne udtrykket mønstre
  som $(\overline{x}, \overline{y})$ eller $\mathcal{C}[\overline{x} ::
  \overline{xs}]$ men der ville ikke kunne udtrykkes mønstre som $(\overline{x},
  \mathcal{C}[\overline{y} :: \overline{ys}])$ da bladene i meta patterns kun
  kan være patvars eller huller.

  Ved at skabelons mønstre er patterns over meta patterns får vi mere
  udtrykskraft og kan derfor udtrykke førnævnte mønster $(\overline{x},
  \mathcal{C}[\overline{y} :: \overline{ys}])$


\item[Scheme body] SML udtryk uden type annotering, infix operatorer, Og
  \texttt{self}, meta patterns og transformers.


\item[Transformer] % M for Megatron, O' for Optimus Prime
  $\mathbb{M}_{\textnormal{\fontsize{2}{3pt}\selectfont egatron}}, \mathbb{O}',
  \mathbb{D}$ er transformere som tager nøjagtigt et ML mønster som input og
  giver et ML udtryk som netop passer i den matchende funktion. \fixme{At some
    point define how the magic works.}


\item[Canonical mapping] $\kappa$ er den kanoniske afbildning af et ML mønster
  til et ML udtryk, som defineret i miniml.


\item[Floor] $\floor{\mathcal{C}}$ er den kanoniske instantiering af et meta
  pattern. Alle patvars i det givne meta pattern bliver instantieret til en ML
  variabel med hensyntagen til capture avoidance.

  Dette bruges i resultatet af en skabelon, da patvars her ikke er bundet til et
  ML pattern.

  Eksempel $\floor{\mathcal{C}}$ $\mathcal{C} = (\diamond, \overline{y})$:
  $\floor{\mathcal{C}} = \floor{(\diamond, \overline{y})} = (\diamond,
  \floor{\overline{y}}) = (\diamond, a)$.
 
\end{description}

Når patvars ($\overline{x}$) bruges i højresiden af en skabelon (skabelons krop)
bliver de implicit erstattet med det ML mønster de er bundet til fra
venstresiden (skabelons mønsteret), se nedenstående eksempel

\begin{example}[Matching/brug af patvars] \

   \fixme{Find ordenligt eksempel navn/tekst}
  
   Givet ML funktionen foo

\begin{verbatim}
fun foo (a,b :: xs) = b+a
  | foo _           = 0
\end{verbatim}

  som matcher reglen

  \[
  \mathcal{C}[\overline{x}::\overline{xs}] =>
  \mathbb{D}(\mathcal{C}[\overline{x}])
  \]

  haves at $\mathcal{C} = \diamond$ og på venstresiden sker følgende
  bindinger

  \[
  \overline{x} \mapsto (a,b), \overline{xs} \mapsto xs
  \]

  så på højresiden bliver $\overline{x}$ erstattet med $(a,b)$ og der haves
  
  \[
  \mathcal{C} [\overline{x}::\overline{xs}] = \mathbb{D}(\mathcal{C}[(a,b)
  ])
  \]

  men da $\mathcal{C} = \diamond$ kan der yderligere reduceres til
  $\mathcal{C} [\overline{x}::\overline{xs}] = \mathbb{D}(a,b)$ hvor
  $\mathbb{D}$ gør det forventede og producere $b+a$.

  \fixme{Måske for tidligt at komme med dette når vi ikke har "`defineret"'
    skabeloner endnu, og der heller ikke er resultat delen af skabeloner}

\end{example}


\subsection{Skabeloner}

En skabelon defineres kun ud fra de mønstre og kroppe som de skal matche. Altså
bruges der ikke syntaks til at matche funktionsnavnet. For at kunne matche
rekursive funktioner introducerer vi nøgleordet \texttt{self} som er en
pladsholder for funktionsnavnet af den funktion der bliver matchet mod
skabelonen.

Ved ikke at udtrykke mere information om funktionene eller dens parametre kan vi
have samme skabelons syntaks for sekventialiseret (curry'et) og ikke
sekventialiseret (uncurry'et) funktions erklæringer.

Det huskes at følgende sekventialiseret funktion 

\begin{verbatim}
fun add n [] = []
  | add n (x::xs) = n+x :: add n xs
\end{verbatim}

ville blive af sukkeret (af flere omgange) til

\begin{verbatim}
val rec add = fn n => 
              fn xs => (fn (n, []) => []
                         | (n, x::xs) => n + x :: add n xs) (n, xs)
\end{verbatim}

og samme funktion på ikke sekventialiseret form

\begin{verbatim}
fun add' (n,[]) = []
  | add' (n, x::Xs) = n+x :: add'(n, xs)
\end{verbatim}

bliver af sukkeret til 

\begin{verbatim}
val rec add' = fn (n,[]) = []
                | (n, x::Xs) = n+x :: add'(n, xs)
\end{verbatim}

Som det ses ender begge tilfælde her med en enkelt anonym funktion (kun den inderste
har interesse hvis der skulle være flere). Hvis den oprindelige funktion var på
sekventialiseret form bliver alle argumenterne sat sammen til en tupel og hvis
den var på ikke sekventialiseret form så var argumentet allerede en tupel.

Denne inderste anonyme funktion har derfor nu et antal klausuler og hvor hvert
klausuls mønster og krop matcher det der var givet i den oprindelige
funktion.

Vi har valgt at definere vores skabeloner på en sådan måde at de minder meget om
ovenstående. Alle klausuler i en skabelon starter på $|$ (hvilket på nær den
første også altid er tilfælde for ML). Vi gør dette af samme årsag som ML,
mulighed for multiline klausuler. Dog kræver vi $|$ for første klausul af
æstetiske grunde (symmetri) samt det giver en mere simpel grammatik og parser
for skabeloner. \fixme{Er dette argument for hvordan vi har udformet skabelon
  syntaksen relevant?}

Vi mener dette tilstræber den mest naturlige måde at udtrykke skabeloner der
matcher ML kode.

Skabeloner defineres altså som følgende n klausuler

\begin{eqnarray*}[rqrl]
| & m_1 & => e_1 \\
  &  & \vdots \\
| & m_n & => e_n
\end{eqnarray*}

Hvor $m_k$ er skabelons mønstre (scheme patterns) der er patterns over meta
patterns og $e_k$ er skabelons kroppe (scheme bodys).

\fixme{Der beskrives slet ikke hvordan og hvorledes med resultat
  omskrivningen. Der beskrives kun den matchende del af skabelonen.}

\subsection{Maching af skabeloner}

\fixme{bedre titel næste gang...}

Der kræves 4 skridt for at verificere om en funktion matcher en skabelon

\begin{enumerate}
\item Antal klausuler stemmer overens i skabelon og funktion der skal matche.

\item Hver klausuls krop fra skabelonen kan ``matches'' med den tilsvarende
  klausuls krop i funktion.

\item $\mathcal{C}[patvar_1]\ldots[patvar_n]$ fra regel $m$ skal matche den
  oprindelige funktions pattern $m$, hvor samtlige $patvar_k$ skal kunne matche
  et deltræ af det oprindelige pattern. Alle disse matchede deltræer må ikke
  overlappe og de vil blive erstattet med $diamond_k$ og $patvar_k$ bliver
  bundet til det deltræ den matchede.

  
  \begin{example} \ 

    \fixme{Burde nok medtage hvad parvars bliver bundet til også.}

    \begin{tabular}{l|l|l} 
      ML Funktions pattern & Skabelon definition & Resulterende
      $\mathcal{C}$ \\ \hline
      
      $(a,b) :: xs$ & $\mathcal{C}[\overline{x} :: \overline{xs}]$ &
      $\diamond$ \\
      
      
      $(b,a) :: xs$ & $\mathcal{C}[\overline{x} :: \overline{xs}]$ &
      $\diamond$ \\

      $(a, x::xs)$ & $\mathcal{C}[\overline{x} :: \overline{xs}]$ &
      $(\overline{a}, \diamond)$ \\

      $(x::xs, b)$ & $\mathcal{C}[\overline{x} :: \overline{xs}]$ &
      $(\diamond, \overline{b})$ \\

      $(x::xs, y::ys)$ & $\mathcal{C}[\overline{x} :: \overline{xs}][\overline{y} :: \overline{ys}]$ &
      $(\diamond_1, \diamond_2)$ eller $(\diamond_2, \diamond_1)$\\
      
    \end{tabular}
    
  \end{example}

\item $\mathbb{D}$ genererer en funktion der sender det resulterende $pat$ hen i
  en $exp$ hvor $exp$ netop er den $exp$ der matcher funktionens $exp$ på
  pågældende plads.

\end{enumerate}

\subsection{Prædefinerede skabeloner}


Nedenfor gives forskellige skabeloner for omskrivning til nogle af de mest
almindelige ML udtryk.

\begin{definition}[Omskrivning af \texttt{map}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}  [\overline{x} :: \overline{xs}] &  => \mathbb{D}
    (\mathcal{C}[ \overline{x}]) :: \mathtt{self}(\kappa \mathsf{(} \mathcal{C} 
    [ \overline{xs} ] \mathsf{) )} \\
    | & \overline{x} & => \mathsf{nil} \\
   \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [ xs ] & => \textsf{map } \left( \textsf{fn } m =>
      \mathbb{D}\left( \floor{\mathcal{C}} [ m ] \right) \right) \ xs
  \end{eqnarray*}
\end{definition}

\begin{definition}[Omskrivning af \texttt{fold}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}[\overline{x} :: \overline{xs}] &  => \mathbb{D} \left( \mathcal{C}
      [\overline{x}],\ \mathtt{self} \left( \mathcal{C}[\overline{xs}] \right) \right) \\
    | & \overline{x} & => 
    \begin{eqnalign}[l:Tl]
      \mathcal{G} & \phantom{some phantom space}  where closed$(\mathcal{G})$
    \end{eqnalign}\\
    \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [xs] & => \textsf{fold } \left( \textsf{fn } (a,b) =>
      \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \ \floor{\mathcal{G}} \ xs
  \end{eqnarray*}

  
\end{definition}

\section{Eksempler}

Følgende eksempler definerer forskellige varianter af funktionen $\mathsf{foo}$
som implementerer forskellige varianter af SML's $\mathsf{map}$ funktion.

\begin{example}[\texttt{map}-instans]
  \begin{eqnarray*}
    (\mathsf{nil}, f) &=>& \mathsf{nil} \\
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f)
  \end{eqnarray*}

  vil den blive normaliseret til
  \begin{eqnarray*}
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f) \\
    \_ &=>& nil
  \end{eqnarray*}

  Da $\mathsf{nil}$ er mest generel, efterfulgt af $x::xs$ og $[x]$. $(\mathsf{nil}, f)$
  bliver erstattet af en bundstreg af generaliseringen da ingen af argumenterne
  bliver brugt på højresiden (bemærk at på højresiden $\mathsf{nil}$ er en
  konstruktør og derfor ikke er bundet til $\mathsf{nil}$ på venstresiden).

  Ovenstående eksempel vil have konteksterne $\mathcal{C} = (\diamond, ),
  \mathcal{D} = f$

  Ved unificering vil man hurtigt kunne fastslå at første klausul er unødvendig
  (kræver 1 $\beta$-reduktion af $\mathsf{foo}$ i andet klausul). Hvis denne
  unificering ikke udføres vil dette eksempel ikke kunne fanges af den
  definerede regel:

  \begin{enumerate}
  \item Antal klausuler passer ikke, funktionen kan ikke matche skabelonen.
  \end{enumerate}
\end{example}



\begin{example}[\texttt{map}-instans]

  \begin{eqnarray*}
    (\mathsf{nil}) &=>& \mathsf{nil} \\
    (x::xs) &=>& x+1 :: \mathsf{foo} xs
  \end{eqnarray*}
  
  Bliver normaliseret til 

  \begin{eqnarray*}
    (x::xs) &=>& x+1 :: \mathsf{foo} xs \\
    x &=>& \mathsf{nil}
  \end{eqnarray*}

  \begin{enumerate}
  \item Antal klausuler matcher.
    
  \item Funktions kroppe kan matche med tilsvarende klausuls kroppe.
    
  \item $\mathcal{C}$ instantieres til $\diamond$
    
    \begin{description}
    \item[Klausul 1] 
      \begin{itemize}
      \item På venstresiden bindes $\overline{x} \mapsto x, \overline{xs} \mapsto xs$.
        
      \item På højresiden fås derfor $\mathcal{C}[\overline{x}] = x$ og
        $\mathcal{C}[\overline{xs}] = xs$        
      \end{itemize}
        
      
    \item[Klausul 2]
      \begin{itemize}
      \item På venstresiden bindes $\overline{x} \mapsto
        x$.
        
      \item På højresiden er der ikke brugt nogle patvars så der sker ikke
        noget.
      \end{itemize}
      
    \end{description}
      
  \item $\mathbb{D}$ genererer funktionen der for input
    $\mathcal{C}[\overline{x}] = x$ returnerer $x + 1$ da dette er udtrykket i
    funktionen som matcher $\mathbb{D}\left( \mathcal{C}[\overline{x}] \right)$
    i skabelonen. Altså $\mathbb{D}(\overline{x}) = \kappa(\overline{x}) + 1$ 
  \end{enumerate}

  Vi har altså nu at funktionen matcher skabelonen og derfor kan omskrives til
  følgende ud fra skabelonenes omskrivning regel

  \begin{eqnarray*}[c]
      \mathcal{C}|[\mathcal{X\!S}|] => \textsf{map } \left( \textsf{fn } m =>
    \mathbf{D}\left( \mathcal{C}|[m|] \right) \right) \mathcal{X\!S} \\
  %
  \Downarrow \\
  %
  xs => \textsf{map } \left( \textsf{fn } m =>
    \left( \textsf{fn } x => x + 1 \right) m \right) xs \\
  \end{eqnarray*}

\end{example}


\begin{example}
  \begin{eqnarray*}
    (nil, \_) &=>& nil\\
    (x::xs, n) &=>& F\ (x * n) :: \mathsf{foo} (xs, n)\\
  \end{eqnarray*}
\end{example}

\begin{example}[\texttt{fold}-instans]

  \begin{eqnarray*}
    (y::ys) &=>& y + \mathtt{self} \left( ys \right) \\
    nil &=>& 0
  \end{eqnarray*}

  Hvilket er normaliseret så det bliver ikke omskrevet.

  \begin{enumerate}
  \item Antal klausuler matcher.

  \item 

  \item $\mathcal{C}$ instantieres til $\diamond$ og $\mathcal{G} = 0$

    \begin{description}
    \item[Klausul 1] $\overline{x} \mapsto y, \overline{xs} \mapsto ys$
      
    \item[Klausul 2] $\overline{x} \mapsto nil$
    \end{description}
    
    
  \item $\mathbb{D}(\overline{n}, \overline{m}) = \kappa(\overline{n}) +
    \kappa(\overline{m})$
  \end{enumerate}

  Vi kan derfor anvende denne skabelon og lave omskrivningen, hvor der haves
  $\floor{\mathcal{C}} = \diamond, \floor{\mathcal{G}} = 0$

  \begin{eqnarray*}[c]
     \floor{\mathcal{C}} [xs]  => \textsf{fold } \left( \textsf{fn } (a,b) =>
      \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \
    \floor{\mathcal{G}} \ xs \\
    %
    \Downarrow \\
    % 
    xs => \textsf{fold } \left( \textsf{fn } (a,b) => a+b
    \right) \ 0 \ xs
  \end{eqnarray*}
  
\end{example}



\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
