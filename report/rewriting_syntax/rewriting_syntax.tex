\documentclass[oneside]{memoir}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

\usepackage[draft]{fixme}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\usepackage{tikz}

\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}


\chapterstyle{hangnum}

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\section{Problem definition}





I nedenstående vil $\alpha$ patterns vil være træer af konstruktører som knuder og $\alpha$ som
blade, hvor tal (SML special consts) opfattes som nulære konstruktører af
simplificerende grunde og har derfor ingen blade.

\subsection{Term definition}
\label{sec:term-definition} \fixme{find på bedre sektions navn}

\begin{description}
\item[patvar] $\overline{x}, \overline{y}, \overline{xs}$ er pattern variable

\item[hole] $\diamond_n$ er n'te "`hul"' i et meta pattern.


\item[ML pattern] $x,y,z$ er ML pattern med $\alpha$ værende .....
  \fixme{Hvordan passer det ind i vores definition af patterns?}


\item[meta pattern] $\mathcal{A}, \mathcal{B}, \mathcal{C}$ er meta patterns
  hvor $\alpha$ kan være pattern variable (patvars) eller huller (holes). Hvis
  der kun er et hul i et meta pattern vil hullet være implicit annoteret med
  $n=1$.

\item[Scheme pattern] Skabelonsmønstre er patterns med $\alpha$ som meta
  patterns. Kan omtales patterns over meta patterns.


\item[Scheme body] SML udtryk uden type annotering, infix operatore og med
  \texttt{self}, meta patterns og .


\item[Transformer] $\mathbb{M}, \mathbb{O}', \mathbb{D}$

%Megatron, Optimus Prime (')

For $\kappa$ værende den kanoniske afbildning af $pat -> exp$ defineret i
miniml.

Definer $\floor{...}$ (Kanonisk metamønster instantiering.

Definer $\floor{\mathcal{C}}$. Eks. $\mathcal{C} = (\diamond, \overline{y})$:
$\floor{\mathcal{C}} = \floor{(\diamond, \overline{y})} = (\diamond,
\floor{\overline{y}}) = (\diamond, a)$.

Forklar hvordan $\overline{x}$ implicit skal erstattes med dets bundne pattern når
de bruges på højresiden, så $foo((a,b)::xs) = b+a$ for reglen $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(\mathcal{C}[\overline{x}])$ hvor på venstresiden
bliver følgende bundet $\overline{x} \mapsto (a,b), \overline{xs} \mapsto xs$ så
på højresiden bliver $\overline{x}$ erstattet med $(a,b)$ og der haves $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(\mathcal{C}[(a,b)])$ hvor
$\mathcal{C} = \diamond$, så der kan yderligere reduceres til $\mathcal{C}
[\overline{x}::\overline{xs}] = \mathbb{D}(a,b)$ hvor $\mathbb{D}$ gør det
forventede og producere $b+a$. ~~~~~~~~~~~~ WUB WUB
\end{description}


Et meta pattern $\mathcal{X}$ er derfor et træ kun bestående af konstruktører som
knuder og pattern variable $\overline{x}$ eller huller $diamond_n$ som
blade. 

I nedenstående er $((a,\ b),\ x\ ::\ y\ ::\ xs)$ en instans af $\mathcal{X}$

\begin{tikzpicture}[]
  
  \node (pair)     {$(,)$};

  \node (X)  [below left of = pair] {$\overline{x}$};

  \node (cons)  [below right of = pair] {$::$};

  \node (Y)  [below left of = cons] {$\overline{y}$};
  \node (Z)  [below right of = cons] {$\overline{z}$};

  \path (pair) edge (X)
        (pair) edge (cons)

        (cons) edge (Y)
        (cons) edge (Z);

\end{tikzpicture}


En skabelon defineres kun ud fra de mønstre og kroppe som de skal matche. Altså
bruges der ikke syntaks til at matche funktionsnavnet. For at kunne matche
rekursive funktioner introducerer vi nøgleordet \texttt{self} som er en
pladsholder for funktionsnavnet af den funktion der bliver matchet mod
skabelonen.

Ved ikke at udtrykke mere information om funktionene eller dens parametre kan vi
have samme skabelons syntaks for curry'et og uncurry'et funktions definitioner.

Det huskes at følgende curry'et funktion 

\begin{verbatim}
fun add n [] = []
  | add n (x::xs) = n+x :: add n xs
\end{verbatim}

ville blive af sukkeret (af flere omgange) til

\begin{verbatim}
val rec add = fn n => fn xs => (fn (n, []) => []
                                 | (n, x::xs) => n + x :: add n xs) (n, xs)
\end{verbatim}

og samme funktion på uncurry'et form

\begin{verbatim}
fun add' (n,[]) = []
  | add' (n, x::Xs) = n+x :: add'(n, xs)
\end{verbatim}

bliver af sukkeret til 

\begin{verbatim}
val rec add' = fn (n,[]) = []
                | (n, x::Xs) = n+x :: add'(n, xs)
\end{verbatim}

Som det ses endes der i begge tilfælde her med en case hvor de oprindelige patterns bliver samlet
i en tupel \fixme{tupel / tubel ?  hvad er det nu der er dansk}. Det samme sker
for uncurry'et funktioner.

Alle klausuler i en skabelon starter på $|$ (hvilket på nær den første også
altid er tilfælde for SML). Vi bruger $|$ af samme årsag som SML, mulighed for
multiline klausuler. Dog kræver vi $|$ for første klausul af æstetiske grunde
(symmetri) samt det giver en simplerer grammatik og parser for
skabeloner. \fixme{Er dette argument for hvordan vi har udformet skabelon
  syntaksen relevant?}

\begin{verbatim}
| m_1 => e_1
.
.
.
| m_n => e_n
\end{verbatim}

Hvis skabelons mønstre var meta patterns ville vi kunne udtrykket mønstre som
$(\overline{x}, \overline{y})$ eller $\mathcal{C}[\overline{x} ::
\overline{xs}]$ men vi ville ikke kunne udtrykke mønstre som $(\overline{x},
\mathcal{C}[\overline{y} :: \overline{ys}])$ da bladene i meta patterns kun kan
være patvars eller huller (se \ref{sec:term-definition}).

Ved at skabelons mønstre er patterns over meta patterns får vi mere udtrykskraft
og kan derfor udtrykke førnævnte mønster $(\overline{x}, \mathcal{C}[\overline{y} ::
\overline{ys}])$

Nedenfor er skabeloner for matchende funktioner:

\begin{definition}[Omskrivning af \texttt{map}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}  [\overline{x} :: \overline{xs}] &  => \mathbb{D}
    (\mathcal{C}[ \overline{x}]) :: \mathtt{self}(\kappa \mathsf{(} \mathcal{C} 
    [ \overline{xs} ] \mathsf{) )} \\
    | & \overline{x} & => \mathsf{nil} \\
   \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [ xs ] & => \textsf{map } \left( \textsf{fn } m =>
      \mathbb{D}\left( \floor{\mathcal{C}} [ m ] \right) \right) \ xs
  \end{eqnarray*}
\end{definition}

\begin{definition}[Omskrivning af \texttt{fold}-instanser] \ \\

  \begin{eqnarray*}[rqrl]
    | & \mathcal{C}[\overline{x} :: \overline{xs}] &  => \mathbb{D} \left( \mathcal{C}
      [\overline{x}],\ \mathtt{self} \left( \mathcal{C}[\overline{xs}] \right) \right) \\
    | & \overline{x} & => \mathcal{G} \\
    \tabpause{\begin{center}$\Downarrow$\end{center}}  
    | & \floor{\mathcal{C}} [xs] & => \textsf{fold } \left( \textsf{fn } (a,b) =>
      \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \ \floor{\mathcal{G}} \ xs
  \end{eqnarray*}
  
  where $\textrm{closed}(\sin\mathcal{G})$
  
\end{definition}


% D (\bar{x}, \bar{y}) = \kappa(\bar{x}) + \kappa(\bar{y})

Der kræves 4 skridt for at verificere om en funktion matcher en skabelon

\begin{enumerate}
\item Antal klausuler stemmer overens i skabelon og funktion der skal matche.

\item Hver klausuls krop fra skabelonen kan ``matches'' med den tilsvarende
  klausuls krop i funktion.

\item $\mathcal{C}[patvar_1]\ldots[patvar_n]$ fra regel $m$ skal matche den
  oprindelige funktions pattern $m$, hvor samtlige $patvar_k$ skal kunne matche
  et deltræ af det oprindelige pattern. Alle disse matchede deltræer må ikke
  overlappe og de vil blive erstattet med $diamond_k$ og $patvar_k$ bliver
  bundet til det deltræ den matchede.

  Eks:
  ML Funktions pattern | Skabelon definition                         | Resulterende $\mathcal{C}$

     (a,b) :: xs       | $\mathcal{C}[\overline{x} :: \overline{xs}]$ | 

     (b,a) :: xs       | 

\item $\mathbb{D}$ genererer en funktion der sender det resulterende $pat$ hen i
  en $exp$ hvor $exp$ netop er den $exp$ der matcher funktionens $exp$ på
  pågældende plads.

\end{enumerate}

\section{Eksempler}

Følgende eksempler definerer forskellige varianter af funktionen $\mathsf{foo}$
som implementerer forskellige varianter af SML's $\mathsf{map}$ funktion.

\begin{example}[\texttt{map}-instans]
  \begin{eqnarray*}
    (\mathsf{nil}, f) &=>& \mathsf{nil} \\
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f)
  \end{eqnarray*}

  vil den blive normaliseret til
  \begin{eqnarray*}
    ([x], g) &=>& [g\ x] \\
    (x::xs, f) &=>& f\ x  :: \mathsf{foo}(xs,f) \\
    \_ &=>& nil
  \end{eqnarray*}

  Da $\mathsf{nil}$ er mest generel, efterfulgt af $x::xs$ og $[x]$. $(\mathsf{nil}, f)$
  bliver erstattet af en bundstreg af generaliseringen da ingen af argumenterne
  bliver brugt på højresiden (bemærk at på højresiden $\mathsf{nil}$ er en
  konstruktør og derfor ikke er bundet til $\mathsf{nil}$ på venstresiden).

  Ovenstående eksempel vil have konteksterne $\mathcal{C} = (\diamond, ),
  \mathcal{D} = f$

  Ved unificering vil man hurtigt kunne fastslå at første klausul er unødvendig
  (kræver 1 $\beta$-reduktion af $\mathsf{foo}$ i andet klausul). Hvis denne
  unificering ikke udføres vil dette eksempel ikke kunne fanges af den
  definerede regel:

  \begin{enumerate}
  \item Antal klausuler passer ikke, funktionen kan ikke matche skabelonen.
  \end{enumerate}
\end{example}



\begin{example}[\texttt{map}-instans]
  \begin{eqnarray*}
    (\mathsf{nil}) &=>& \mathsf{nil} \\
    (x::xs) &=>& x+1 :: \mathsf{foo} xs
  \end{eqnarray*}

  Bliver normaliseret til 
  \begin{eqnarray*}
    (x::xs) &=>& x+1 :: \mathsf{foo} xs \\
    x &=>& \mathsf{nil}
  \end{eqnarray*}

  \begin{enumerate}
  \item Antal klausuler matcher.

  \item Funktions kroppe kan matche med tilsvarende klausuls kroppe.

  
  \item 
    \begin{description}
    \item[Klausul 1] $\mathcal{C}$ instantieres til $(x::xs)$.
      \begin{itemize}
      \item $\mathcal{C}|[\mathcal{X}::\mathcal{X\!S}|]$ på venstresiden
        erstatter $x::xs$ i $\mathcal{C}$ til $\diamond_1$ da $pat_1 =
        \mathcal{X}::\mathcal{X\!S}$ i venstresidens
        $\mathcal{C}|[pat_1|]\ldots|[pat_n|]$. Heraf bindes $\mathcal{X} \mapsto
        x, \mathcal{X\!S} \mapsto xs$. Der haves derfor nu at $\mathcal{C} =
        \diamond_1$

      \item På højresiden fås derfor $\mathcal{C}|[\mathcal{X}|] = x$ og
        $\mathcal{C}|[\mathcal{X\!S}|] = xs$ ved substitution af $pat_n$ i
        $\mathcal{C}|[pat_1|]\ldots|[pat_n|]$ for $\diamond_n$ i $\mathcal{C}$.
      \end{itemize}
      

    \item[Klausul 2] $\mathcal{C}$ instantieres til $x$ (kunne også have været
      $\_$ (wildcard).
      \begin{itemize}
      \item Trivielt/uinteressant. \fixme{do it...}
      \end{itemize}

    \end{description}

  \item $\mathbb{D}$ genererer funktionen der for input
    $\mathcal{C}|[\mathcal{X}|] = x$ returnerer $x + 1$ da dette er udtrykket i
    funktionene som matcher $\mathbb{D}\left( \mathcal{C}|[\mathcal{X}|]
    \right)$ i skabelonen. Altså $\mathbb{D}(x) = x + 1$ eller skrevet som som
    SML funktion $\mathbb{D} = \textsf{fn } x => x + 1$ og $\mathbb{D}\left(
      \mathcal{C}|[\mathcal{X}|] \right) = \left( \textsf{fn } x => x + 1
    \right) \left( \mathcal{C}|[\mathcal{X}|] \right) $.
  \end{enumerate}

  Vi har altså nu at funktionen matcher skabelonen og derfor kan omskrives til
  følgende ud fra omskrivnings definitionen og de bundne meta variable defineret
  ovenfor

  \begin{eqnarray*}[c]
      \mathcal{C}|[\mathcal{X\!S}|] => \textsf{map } \left( \textsf{fn } m =>
    \mathbf{D}\left( \mathcal{C}|[m|] \right) \right) \mathcal{X\!S} \\
  %
  \Downarrow \\
  %
  xs => \textsf{map } \left( \textsf{fn } m =>
    \left( \textsf{fn } x => x + 1 \right) m \right) xs \\
  \end{eqnarray*}

\end{example}


\begin{example}
  \begin{eqnarray*}
    (nil, \_) &=>& nil\\
    (x::xs, n) &=>& F\ (x * n) :: \mathsf{foo} (xs, n)\\
  \end{eqnarray*}
\end{example}

\begin{example}[\texttt{fold}-instans]

  \begin{eqnarray*}
    (y::ys) &=>& y + \mathtt{self} \left( ys \right) \\
    nil &=>& 0
  \end{eqnarray*}

  Hvilket er normaliseret så det bliver ikke omskrevet.

  Følgende bliver instantieret

  $\mathcal{C} = \diamond, \mathcal{G} = 0, \mathbb{D}(\overline{n},
  \overline{m}) = \kappa(\overline{n}) + \kappa(\overline{m}),
  \floor{\mathcal{C}} = \diamond, \floor{\mathcal{G}} = 0$.

  

  \begin{description}
    \item[Klausul 1] $\overline{x} = y, \overline{xs} = ys$

    \item[Klausul 2] $\overline{x} = nil$
  \end{description}

  \begin{eqnarray*}
    xs &=>& \textsf{fold } \left( \textsf{fn } (a,b) => \mathbb{D}(a,b)
    \right) \ \mathcal{G} \ xs
  \end{eqnarray*}
  
\end{example}



\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
