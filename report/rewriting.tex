\subsection{Semi-automatic rewriting}
We define a set of rewriting rules:
\begin{eqnarray*}
t_0 &\rightarrow& t_0'\\
&\vdots&\\
t_n &\rightarrow& t_n'
\end{eqnarray*}

where $t_i$ and $t_i'$ are program terms and the free variables of $t_i'$ is a subset of the free
variables of $t_i$.
\\

A term $u$ is an instance of a term $t$ if and only if there exists terms $x_i$ such that
\begin{eqnarray}\label{eq:term-instance}
t[x_0 / v_0] \cdots [x_n / v_n] =_{\alpha} u
\end{eqnarray}
where $v_0, \ldots, v_n$ are the free variables of $t$.

The rule $t \rightarrow t'$ applies to $u$ with the result
\begin{eqnarray}\label{eq:term-result}
u' =_{\alpha} t'[x_0 / v_0] \cdots [x_n / v_n]
\end{eqnarray}
where the name mapping implied by the alpha equivalence of (\ref{eq:term-instance}) corresponds to
that of (\ref{eq:term-result}).

Notice that the free variables of $t'$ is a subset of $\{v_0, \ldots, v_n\}$.

\subsubsection{Rule labeling and grouping}
A large set of rewriting rules suggesting a large amount of rewritings may confuse the programmer as
to which rewritings are used in which places. Therefore we label each rule with a name and an
optional description.

Since some rules group naturally together (e.g., multiple rules for rewriting boolean expressions)
we make it possible to arrange multiple rules under a common group name.

Grouping and labeling makes it easier for the programmer to see what is going on. It could also make
it possible to turn on or off individual groups of rules or specific rules as well as computing the
transitive closure of groups of rules.
