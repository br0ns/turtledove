\section{Grammar}

\newcommand{\fn}{\ttt{fn}\ }
\newcommand{\rec}{\ttt{rec}\ }

An SML like grammar, without types, is presented below which will be the basis
of defining normal forms for SML functions. Well formed code in the below
grammar also includes that all constructors used in the patterns of a match must
be of the same data type. For example the unary constructors made from
\ttt{[0-9]}$^{+}$ could be defined to belong to the data type \textit{number}

\begin{eqnarray*}[rqcql:Tl]
  var & = & \ttt{[a-z]$^{+}$}                          & Identifiers\\
  con & = & \ttt{[A-Z][a-z]$^{*}$ | [0-9]$^{+}$}        & Constructors\\
% Matches
  match & ::= & \epsilon                              & Empty match\\
  & & pat\texttt{.}exp\ \texttt{|}\ match             & Pattern \ttt{=>} expression\\
% Patterns
  pat & ::= & var                                     & Variable\\
  & & con                                             & Constructor of arity $0$\\
  & & con\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} & Constructor of arity $n$\\
% Expressions
  exp & ::= & var                                     & Variable\\
  & & exp_1\ exp_2                                     & Application\\
  & & \fn match                                       & Function\\
  & & con                                             & Constructor of arity $0$\\
  & & con\texttt{(}exp_1\texttt{,} \ldots\texttt{,} exp_n\texttt{)} & Constructor of arity $n$\\
% Declarations
  dec & ::= & var \mapsto exp                         & value binding\\
  & & \rec var \mapsto exp                            & Recursive value binding\\
  & & dec_1 \ttt{;} \cdots \ttt{;} dec_n              & Sequence, $n \geq 2$\\
  & & \epsilon                                        & Empty program\\
\end{eqnarray*}

We use (with superfixes, subfixes and primes) $v$, $c$, $m$, $p$, $e$ and $d$ to
range over $var$, $con$, $match$, $pat$, $exp$ and $dec$ respectively.

No pattern may contain a given variable more than once.

\paragraph{Environment.} For simplicity it is not possible to define data
types/constructors in the grammar, but we will assume two fixed constructor
environments, $\rho$ and $\psi$, containing this information as this is solely
used when determining coverage (see \fref[plain]{sec:cover}). $\rho$ is a mapping
of constructors to their data type and $\psi$ is a mapping of data types to a
list of all constructors of that data type.

\section{List of symbols}

Below is a summarised list of symbols that will be introduced in this chapter

\begin{tabular}{| >{$}c<{$} | p{18em} | l|}
  \hline
  \textbf{Symbol} & \textbf{Description} & \textbf{Defined at} \\ \hline
  ++ & Union of two arbitrary mappings. & \Fref{sec:auxil-defin}  \\ \hline
  = & Syntactic equality. & \\ \hline
  ==_\pi & Equivalence of two patterns. & \Fref{def:equivalence-patterns} \\
  \hline
  ==a & Alpha equivalence of two expressions or pattern-expression
  pairs. & \Fref{def:alpha-equivalence} \\ \hline
  \sim & Semantic equivalence of two
  expressions. & \Fref{sec:semantic-equivalence} \\ \hline
  \lessdot & Some total ordering on constructors and variables. & \Fref{def:pat-total-order-strict} \\ \hline
  <, \ <=& Total ordering of patterns & \Fref{lem:pat-total-orderings} \\
  \hline
  <', \ <='& Partial ordering of patterns & \Fref{lem:pat-partial-orderings} \\
  \hline
  || & Confusion of two patterns (when they don't partially order) &
  \Fref{def:pat-confusion} \\ \hline
  ->e & Elimination of one unused pattern from a match. &
  \Fref{def:shadowed-patterns-1} \\ \hline
  |> & Generalisation of a single pattern-expression pair. & \Fref{def:gener-patt} \\ \hline
  ->g & Generalisation of one pattern in a match. & \Fref{def:gener-match} \\ \hline
\end{tabular}


\section{A note about evaluation}
We expect programs to be run in an environment containing predefined functions
(that is variables bound to predefined functions) and constructors. Thus the
program
\begin{quote}
% \begin{verbatim}
\ttt{x $\mapsto$ plus (pair (1, 8))}
% \end{verbatim}
\end{quote}
might make perfect sense (if in particular \ttt{plus} is a variable bound to a
suitable function (perhaps addition), and \texttt{pair}, \texttt{1} and
\texttt{8} are constructors of arity 2, 0 and 0, respectively).
\section{Auxiliary definitions}
\label{sec:auxil-defin}

In the following we define what we mean by equivalence of patterns (with a
permutation of variables), free variables (for expressions, matches and
patterns), substitution (in expressions) and alpha equivalence (of expressions).

\paragraph{Note.}
\begin{enumerate}
\item
\label{item:note-plusplus}
If $f : A -> B$ and $g : A -> B$ are arbitrary mappings then
\begin{eqnarray*}[rlqTl]
  (g ++ f)(x) &= f(x) & if $x \in \Dom(f)$\\
  (g ++ f)(x) &= g(x) & otherwise
\end{eqnarray*}
and
\[
  \Dom (g ++ f) = \Dom (g) \cup \Dom (f).
\]


\item
We write $p \subseteq p'$ to mean that $p$ is a subpattern of $p'$. More
precisely this is the case if $p = p'$ or if $p' = c \ttt{(} p_1 \ttt{,} \ldots
\ttt{,} p_n \ttt{)}$ and $p \subseteq p_i$ for some $i \in \{1, \ldots, n\}$.

In particular we have\footnote{See \fref{sec:free-variables}
  for the definition of $\FV_{pat}$.} $x \sqsubseteq p$ exactly when $x \in
\FV_{pat}(p)$. The relation is obviously reflexive.

\begin{example}\ \\
  \label{ex:suppattern1}
  Recall that lowercase identifiers are variables, and uppercase ones are
  constructors. Variables as subpatterns:
  \begin{eqnarray*}
    \ttt{x} \sqsubseteq \ttt{A(x,y)} \qquad
    \ttt{y} \sqsubseteq \ttt{A(x,y)} \qquad
    \ttt{z} \not \sqsubseteq \ttt{A(x,y)}
  \end{eqnarray*}
  Patterns as subpatterns:
  \begin{eqnarray*}
    \ttt{A(x,y)} \sqsubseteq \ttt{B(A(x,y),z)} \qquad
    \ttt{A(x,y)} \not \sqsubseteq \ttt{A(A(a,b),c)} \qquad
  \end{eqnarray*}
\end{example}

\item
The syntactic category $pat$ is a proper subset of $exp$. Let $\kappa : pat ->
exp$ be the canonical mapping from $pat$ to $exp$. It is injective so it has a
left inverse $\kappa^{-1} : exp -> pat$. $\kappa^{-1}$ is clearly not total.
\end{enumerate}

\subsection{Equivalence of patterns}
\label{sec:equivalence-patterns}
We say that two patterns are equivalent if they can be transformed into
each other by a suitable renaming of the variables.

If $p_1$ and $p_2$ are equivalent we write $==_\pi$ where $\pi$ is a permutation
of variables, such that for each variable $x$ in $p_1$ its counterpart in $p_2$
is $\pi(x)$.

For example we have $A(x,y) ==_\pi A(z,x)$ where $\pi = [x \mapsto z, y \mapsto x]$.

\fixme{maybe: show that sigma is a permutation of variables}

\begin{definition}[Equivalence of patterns, $==_\pi$]
\label{def:equivalence-patterns}
  \begin{eqnarray}[rlqTl]
    v_1 &==_{\pi} v_2  & where $\pi = [v_1 \mapsto v_2]$ \label{eq:struct-eq-var} \\
    c\ttt{(}p^1_1 \ttt{,} \ldots \ttt{,} p^1_n \ttt{)} & ==_{\pi}
    c\ttt{(}p^2_1 \ttt{,} \ldots \ttt{,} p^2_n \ttt{)} & \label{eq:struct-eq-con}
  \end{eqnarray}
where \fref{eq:struct-eq-con} holds if
\begin{eqnarray*}[c]
  p^1_1 ==_{\pi_1} p^2_1 \\
  \vdots \\
  p^1_n ==_{\pi_n} p^2_n
\end{eqnarray*}
and $\pi = \pi_1 ++ \ldots ++ \pi_n$.

Note that the domains of each of the $\sigma$s are disjoint because no variable
can occur more than once in a pattern (by the definition of the syntax).

We write $==$ to mean $==_\pi$ (with a suitable non-fixed $\pi$) where $\pi$ has no
interest. Equivalence of patterns is defined by $==_\pi$, \emph{only} when $\pi$
is not fixed.
\end{definition}

\begin{example}[Equivalence of patterns, $==_{\pi}$]
  \label{ex:pattern-equiv1}
  \begin{eqnarray*}
    \ttt{A(x,y)} &==_{\pi}& \ttt{A(f,g)}\\
    \ttt{A(f,g)} &==_{\pi'}& \ttt{A(x,y)}
  \end{eqnarray*}
with
  \begin{eqnarray*}
    \pi &=& [x\mapsto f, y \mapsto g] \\
    \pi' &=& [f \mapsto x, g \mapsto y]
\end{eqnarray*}

Whereas these patterns are not equivalent

  \begin{eqnarray*}
    \ttt{A(x,y)} &\not ==& \ttt{B(h,j)} \\
    \ttt{1} &\not ==& \ttt{2}
  \end{eqnarray*}
\end{example}

\fixme{Show equivalence relation: reflexive, symmetric and transitive.}
\fixme{maybe: show $p_1 ==_\pi p_2$ iff $p_2 ==_{\pi^{-1}} p_1$.}


\subsection{Free variables}\label{sec:free-variables}

We denote the free variables of expressions, matches and patterns with the tree
functions $\FV_{exp}$, $\FV_{match}$ and $\FV_{pat}$, respectively.

\begin{definition}[Free variables of expressions, $\FV_{exp}$]\ \\
  Inductively defined:
  \begin{eqnarray}
    \FV_{exp} (v) &=& \{v\} \\
    \FV_{exp} (\fn m) &=& \FV_{match} (m) \\
    \FV_{exp} (e_1e_2) &=& \FV_{exp} (e_1) \cup \FV_{exp} (e_2) \\
    \FV_{exp} (c\ttt{(}e_1\ttt{,} \ldots \ttt{,} e_n \ttt{)}) &=& \FV_{exp}
    (e_1) \cup \ldots \cup \FV_{exp} (e_n)
  \end{eqnarray}
\end{definition}

\begin{definition}[Free variables of matches, $\FV_{match}$]\ \\
  Inductively defined:
  \begin{eqnarray}
    \FV_{match} (\epsilon) &=& \emptyset \\
    \FV_{match} (p\ttt{.}e\ \ttt{|}\ m) &=& \left( \FV_{exp}(e) \setminus
      \FV_{pat}(p) \right) \cup \FV_{match} (m)
  \end{eqnarray}
\end{definition}

\begin{definition}[Free variables of patterns, $\FV_{pat}$] \ \\
  Inductively defined:
  \begin{eqnarray}
    \FV_{pat} (v) &=& \{v\} \\
    \FV_{pat} (c\ttt{(}p_1\ttt{,} \ldots \ttt{,} p_n\ttt{)}) &=& \FV_{pat} (p_1)
    \cup \ldots \cup \FV_{pat} (p_n)
  \end{eqnarray}
\end{definition}

\begin{example}[Free variables, $\mrm{FV}$]
\label{ex:free-variables1}
\begin{eqnarray*}[c]
  \FV_{exp} \left(
    \begin{eqnalign}[Tl]
\begin{lstlisting}
fn Nil . Nil
  | Cons (x, xs) . Cons(f x, g xs)
\end{lstlisting}
    \end{eqnalign}
  \right) = \{\ttt{f}, \ttt{g} \} \\
%
  \FV_{match} \left(
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (x, Nil) . Cons(x, y)
\end{lstlisting}
    \end{eqnalign}
  \right) = \{\ttt{y}\} \\
%
  \FV_{pat} \left(
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (x, xs)
\end{lstlisting}
    \end{eqnalign}
  \right) = \{\ttt{x}, \ttt{xs}\} \\
\end{eqnarray*}
\end{example}


\subsection{Substitution}
We define substitution in expressions. An expression can be substituted for any
(sub)expression of an expressions, not just variables.

\begin{definition}[Substitution]\ \\
  If $e_1$, $e_2$ and $e_3$ are expressions we write $e_1[e_2/e_3]$ to be the
  result of substituting all occurrences of $e_3$ in $e_1$ with $e_2$.
  \begin{eqnarray}
    e_1[e_2/e_3] &=& e_2 \quad \mrm{if}\ e_1 = e_3 \label{eq:subst-sub}\\
    (e^1_1 e^2_1)[e_2/e_3] &=& e^1_1[e_2/e_3] e^2_1[e_2/e_3] \label{eq:subst-app}\\
    \fn p_1 \texttt{.} e_1 \texttt{|} m &=& \fn p_1 \texttt{.} e'_1
    \texttt{|} m' \label{eq:subst-lam}\\
    (c \texttt{(}e^1_1 \texttt{,} \ldots \texttt{,} e^1_n \texttt{)})[e_2/e_3]
    &=& c \texttt{(}e^1_1[e_2/e_3] \texttt{,} \ldots \texttt{,} e^1_n[e_2/e_3]
    \texttt{)} \label{eq:subst-con}
  \end{eqnarray}
Where in \fref{eq:subst-lam} we have
\begin{eqnarray*}[rlqTl]
  e'_1 &= e_1 & if $\kappa^{-1}(e_3) \subseteq p_1$\\
  e'_1 &= e_1[e_2/e_3]
\end{eqnarray*}
and
\[
(\fn m)[e_2/e_3] = \fn m'
\]

In \fref[plain]{eq:subst-app}, \fref[plain]{eq:subst-lam} and
\fref{eq:subst-con}  we require that \fref[plain]{eq:subst-sub} does not apply.

Note that in \fref[plain]{eq:subst-sub} we require $e_1$ and $e_3$ to be exactly
equal, not just alpha equivalent.
\end{definition}

\begin{example}[Substitution]
\label{ex:substituation1}

\begin{eqnarray*}[c]
\left(
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn x . x
  | y . x
\end{lstlisting}
  \end{eqnalign}
\right) \left[ \ttt{z}/\ttt{x} \right] \quad = \quad
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn x . x
  | y . z
\end{lstlisting}
  \end{eqnalign} \\
%
\left(
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn x . Cons (1, x)
\end{lstlisting}
  \end{eqnalign}
\right) \left[ \ttt{z}/\ttt{Cons (1, x)} \right] \quad = \quad
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn x . z
\end{lstlisting}
  \end{eqnalign} \\
\end{eqnarray*}

whereas this is not

\begin{eqnarray*}
\left(
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn x . x
\end{lstlisting}
  \end{eqnalign}
\right) [ \ttt{z}/\ttt{x} ] \quad \neq \quad
  \begin{eqnalign}[Tl]
\begin{lstlisting}
fn z . z
\end{lstlisting}
  \end{eqnalign}
\end{eqnarray*}
\end{example}

\subsection{Alpha equivalence}
\label{sec:alpha-equivalence}

We define alpha equivalence for expressions and for pattern-expression pairs. We
use the symbol $==a$ for both relations.

\begin{definition}[Alpha equivalence of expressions, $==a$]\ \\
\label{def:alpha-equivalence}
  First we define alpha equivalence given a mapping of bound variables:
  \begin{eqnarray}
    \sigma |- v_1 &==a& v_2 \label{eq:alpha-var} \\
    \sigma |- e^1_1e^1_2 &==a& e^2_1e^2_1 \label{eq:alpha-exp} \\
    \sigma |- \fn p^1_1 \texttt{.} e^1_1 \texttt{|} \ldots \texttt{|} p^1_n
    \texttt{.} e^1_n &==a& \fn p^2_1 \texttt{.} e^2_1 \texttt{|} \ldots \texttt{|} p^2_n
    \texttt{.} e^2_n \label{eq:alpha-match} \\
    \sigma |- c\ttt{(}e^1_1 \ttt{,} \ldots \ttt{,} e^1_n \ttt{)} &==a&
    c\ttt{(}e^2_1 \ttt{,} \ldots \ttt{,} e^2_n \ttt{)} \label{eq:alpha-con}
  \end{eqnarray}
where \fref{eq:alpha-var} holds
\begin{eqnarray*}[rlqTl]
\sigma (v_1) &= v_2 & if $v_1 \in \Dom(\sigma)$\\
v_1 &= v_2 & otherwise,
\end{eqnarray*}
\fref{eq:alpha-exp} holds if
\[
\sigma |- e^1_1 ==a e^2_1 \land \sigma |- e^1_2 ==a e^2_1,
\]
\fref{eq:alpha-match} holds if
\begin{eqnarray*}
  (p^1_1, e^1_1) &==a& (p^2_1, e^2_1)\\
  &\vdots&\\
  (p^1_n, e^1_n) &==a& (p^2_n, e^2_n)
\end{eqnarray*}
and \fref{eq:alpha-con} holds if
\[
\sigma |- e^1_1 ==a e^1_n \land \ldots \land \sigma |- e^2_1 ==a e^2_n.
\]

\begin{definition}[Alpha equivalence of pattern-expression pairs, $==a$]\ \\
\label{def:alpha-equivalence-patexp}
  Again we assume a mapping of bound variables. It is the case that
  \[
  \sigma |- (p_1, e_1) ==a (p_2, e_2)
  \]
  exactly when $p_1 ==_\pi p_2$ and
  \[
  \sigma ++ \pi |- e_1 ==a e_2
  \]
\end{definition}

If $e_1$ and $e_2$ are alpha equivalent expressions we write $e_1 ==a e_2$ which
is a shorthand for $[] |- e_1 ==a e_2$. Similarly for pattern-expression pairs.
\end{definition}

\begin{example}[Alpha equivalence, $==a$]\ \\
\label{ex:alpha-equivalence1}
  We have
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
fn Nil . Nil
  | Cons (x, xs) . Cons(f x, g xs)
\end{lstlisting}
    \end{eqnalign}
    ==a
    \begin{eqnalign}[Tl]
\begin{lstlisting}
fn Nil . Nil
  | Cons (y, ys) . Cons(f y, g ys)
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
  
  whereas the example below is not, as the free variables are not the same
  
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
fn Nil . Nil
  | Cons (x, xs) . Cons(f x, g xs)
\end{lstlisting}
    \end{eqnalign}
    \not ==a
    \begin{eqnalign}[Tl]
\begin{lstlisting}
fn Nil . Nil
  | Cons (y, ys) . Cons(h y, j ys)
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
\end{example}

\section{Semantic equivalence}
\label{sec:semantic-equivalence}
We write $e_1 \sim e_2$ if $e_1$ and $e_2$ are semantically equivalent. That is
if $e_2$ is substituted for $e_1$ (or vice versa) in any program $d$ to obtain
$d'$, then if $d$ evaluates to something in an environment $\sigma$ then $d'$
evaluates to that something in $\sigma$, and if $d$ diverges in $\sigma$ so does
$d'$.

\section{Orderings on patterns}
\label{sec:orderings-patterns}
We define a total ($<=$) relation on patterns, and a partial ($<='$) relation on
the quotient set of patterns by structural equivalence. Then we show that they
indeed are orderings.

We write $<$ and $<'$ for $<=$ and $<='$ strict (or irreflexive) counterparts
respectively.

As it turns out it is easier to define $<$ and $<='$ directly and then define
$<=$ and $<'$ in turn of those.

\begin{definition}[Strict total ordering, $<$]\ \\
  \label{def:pat-total-order-strict}
  Assume a total strict ordering $\lessdot$ on constructors and
  variables\footnote{For example let all constructors come before all variables
    and let variables and constructors be ordered lexicographically among
    themselves. Note that constructors and variables are not compared in the
    definition of $<$.}. We inductively define:
  \begin{eqnarray}
    v_1 &<& v_2 \quad \mrm{if}\ v_1 \lessdot v_2\label{eq:pat-total-order-strict-var}\\
    c\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<& v\\
    c_1\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<&
    c_2\texttt{(}p'_1\texttt{,} \ldots\texttt{,} p'_m\texttt{)}\label{eq:pat-total-order-strict-con}
  \end{eqnarray}
  Where \fref{eq:pat-total-order-strict-con} holds if
  \[
  c_1 \lessdot c_2 \lor (c_1 = c_2 \land ( p_1 < p'_1 \lor p_1 = p'_1 \land (\ldots p_n < p'_n \ldots )))
  \]
\end{definition}

\begin{example}[Strict total ordering on patterns, $<$]
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (y, z)
\end{lstlisting}
    \end{eqnalign}
    <
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (x, z)
\end{lstlisting}
    \end{eqnalign}
    <
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Snoc (a, b)
\end{lstlisting}
    \end{eqnalign}
    <
    \begin{eqnalign}[Tl]
\begin{lstlisting}
a
\end{lstlisting}
    \end{eqnalign}
    <
    \begin{eqnalign}[Tl]
\begin{lstlisting}
b
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
  Note: Keep in mind that the exact names of the variables are unimportant.
\end{example}

\begin{definition}[Total ordering, $<=$]\ \\
  \label{def:pat-total-order-weak}
  We define the reflexive cousin:
  \begin{eqnarray*}
    p_1 <= p_2 \Longleftrightarrow p_1 < p_2 \lor p_1 = p_2
  \end{eqnarray*}
\end{definition}



\begin{definition}[Partial ordering, $<='$]\ \\
  \label{def:pat-partial-order-weak}
  We say that $p_2$ weakly generalises $p_1$ or $p_1$ is at least as specific as
  $p_2$ and we write $p_1 <=' p_2$. Inductively defined.
  \begin{eqnarray}
    p &<='& v \label{eq:pat-partial-order-weak-var}\\
    c_1\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<='&
    c_2\texttt{(}p'_1\texttt{,} \ldots\texttt{,} p'_m\texttt{)}
    \label{eq:pat-partial-order-weak-con}
  \end{eqnarray}
  Where \fref{eq:pat-partial-order-weak-con} holds if
  \begin{eqnarray*}
    c_1 &=& c_2 \quad \land\\
    p_1 &<='& p'_1 \quad \land\\
    &\ldots&\\
    p_n &<='& p'_n
  \end{eqnarray*}
\end{definition}



\begin{definition}[Strict partial ordering, $<'$]\ \\
  \label{def:pat-partial-order-strict}
  We define the strict counterpart of $<='$ by
  \begin{eqnarray*}
      p_1 <' p_2 \Longleftrightarrow p_1 <=' p_2 \land p_1 \not == p_2
  \end{eqnarray*}
\end{definition}

\begin{example}[Strict partial ordering on patterns, $<'$]
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (y, Nil)
\end{lstlisting}
    \end{eqnalign}
    <'
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Cons (x, z)
\end{lstlisting}
    \end{eqnalign}
    <'
    \begin{eqnalign}[Tl]
\begin{lstlisting}
b
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
  Keeping in mind that the exact names of the variables are unimportant.
\end{example}


\begin{lemma}[Total ordering]\ \\
  \label{lem:pat-total-orderings}
  The relation $<=$ is a total ordering, and $<$ is a strict total ordering on
  patterns.

  Proof is given in \fref{sec:proof-total-orderings}
\end{lemma}


\begin{lemma}[Partial ordering]\ \\
  \label{lem:pat-partial-orderings}
  The relation $<='$ is a partial ordering and $<'$ is a strict partial ordering
  on the equivalence classes of patterns modulo structural equivalence
  ($pat_{/_{==}}$).

  Proof is given in \fref{sec:proof-partial-orderings}
\end{lemma}

We write $p_1 > p_2$, $p_1 >= p_2$, $p_1 >' p_2$ and $p_1 >=' p_2$ to mean $p_2
< p_1$, $p_2 <= p_1$, $p_2 <' p_1$ and $p_2 <=' p_1$ respectively.

\begin{lemma}[]\ \\
  \label{lem:total-implies-partial}
  If two patterns $p_1$ and $p_2$ are ordered by the partial ordering then they
  are also ordered by the total one. That is
  \begin{eqnarray*}
    p_1 <' p_2 \Longrightarrow p_1 < p_2
  \end{eqnarray*}
\end{lemma}
\begin{proof}
  Straightforward using induction.
\end{proof}

\begin{definition}[Confusion, $||$]\ \\
  \label{def:pat-confusion}
  Let two patterns $p_1$ and $p_2$ be given. If it is the case that neither $p_1
  <=' p_2$ nor $p_1 >=' p_2$ we say that $p_1$ and $p_2$ are confused and we
  write $p_1 || p_2$.
\end{definition}

\begin{lemma}[Unique relation]\ \\
  \label{lem:unique-rel}
  Given two patterns $p_1$ and $p_2$ exactly one of the following hold
  \begin{eqnarray*}
    p_1 &==& p_2\\
    p_1 &<'& p_2\\
    p_1 &>'& p_2\\
    p_1 &||& p_2
  \end{eqnarray*}
\end{lemma}
\begin{proof}
  Immediately by inspection.
\end{proof}

\begin{lemma}[]\ \\
  \label{lem:more-specific-confused}
  If $p_1 <' p_2$ and $p_2 || p_3$, then $p_1 || p_3$.

  Proof is given in \fref{sec:proof-partial-orderings}
\end{lemma}


\section{Eliminating unused patterns}
A function is simply a match. And a match is a list of pairs of patterns and
corresponding bodys.

The input to a function is tried against the patterns from top to bottom. An
unused pattern is a pattern that will never see a value which it matches.

\paragraph{Elimination reasons}\ \\
This can happen for two reasons.
\begin{enumerate}
\item The pattern will never be tried against the input because the input
  matches an earlier pattern. \label{item:unused-reason-1}
\item The pattern is only tried against inputs it doesn't match. \label{item:unused-reason-2}
\end{enumerate}

\subsection{Cover}
\label{sec:cover}
\fixme{det her skal vidst lige luges lidt}

We define a cover to be a set of patterns such that for every input at least one
of the patterns will match that input and we write $Cov(P)$ if $P$ is a cover.

\[
  m = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|} p_n\texttt{.}e_n
\]

There are two cases if we only look at nullary constructors
\begin{enumerate}
\item Trivially we have a cover with $P = \{p_1,\ldots,p_i\}$ for $1 \leq i \leq
  n$ if $p_i$ is a variable
  
  
\item Or we have a cover with $P = \{p_1,\ldots,p_j\}$ for $1 \leq j \leq n$ if
  the set $C$ formed by the constructors of $P$ and the set $D$ formed of all
  the constructors belonging to the data type of $p_1$ are equal. The set $D$
  can be found by looking up the data type of $p_1$ in $\rho$ and then looking
  up the data type in $\psi$ to get $D$.

\end{enumerate}

\noindent
where the cover $Cov(P)$ will be of which ever set is the smallest.

For constructors of arity $k$, the arguments to a constructor must also form a
cover, resulting in more than one pattern for a given constructor is needed to
form its own cover.

\begin{lemma}\ \\
  Any pattern following a cover is unused because of elimination reason
  \ref{item:unused-reason-1}.
\end{lemma}

\subsection{Shadowed patterns}
\label{sec:shadowed-patterns}
If a pattern is unused because of elimination reason \ref{item:unused-reason-2} we say that
it is shadowed.
\begin{definition}[Shadowed]\ \\
  Let
  \[
  m = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|} p_n\texttt{.}e_n
  \]
  If $p_j <=' p_i$ for some $1 \leq i < j \leq n$, then $p_j$ is shadowed (by
  $p_i$).
\end{definition}

\subsection{Elimination}

We can now define the elimination of unused patterns.
\begin{definition}[Elimination, $->e$]\ \\
\label{def:shadowed-patterns-1}
  We define a reduction relation $->e$ that expresses the
  elimination of exactly one pattern from a match.

  Let
  \[
  m = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|} p_n\texttt{.}e_n
  \]
  If there exist a $p_i$ such that $\{p_1, \ldots, p_{i-1}\}$ is a cover or
  $p_i$ is shadowed, then it is unused and can be eliminated. The resulting
  match is
  \[
  m' = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|}
  p_{j-1}\texttt{.}e_{j-1} \texttt{|} p_{j+1}\texttt{.}e_{j+1} \texttt{|}
  \ldots \texttt{|} p_n\texttt{.}e_n,
  \]
  and we write $m ->e m'$.
\end{definition}

\begin{example}[Elimination, $->e$]\ \\
  The first two patterns make a cover (assuming the only constructors are
  \ttt{Cons} and \ttt{Nil}) so the last pattern is eliminated.
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
  Cons(x, xs) . Cons (x, xs)
| Nil . Nil
| x . x
\end{lstlisting}
    \end{eqnalign}
    ->e
    \begin{eqnalign}[Tl]
\begin{lstlisting}
  Cons(x, xs) . Cons (x, xs)
| Nil . Nil
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
  The second pattern in the example below is shadowed by the first pattern and
  is thus eliminated.
  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
  Cons (x, y) . Cons (x, y)
| Cons (Cons (x, y), z) . Cons (Cons (x, y), z)
| Nil
\end{lstlisting}
    \end{eqnalign}
    ->e
    \begin{eqnalign}[Tl]
\begin{lstlisting}
  Cons (x, y) . Cons (x, y)
| Nil
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}

\end{example}

\begin{lemma}[Preservation]\ \\
  If an unused pattern is removed from a program, then the resulting program is
  semantically equivalent.

  That is
  \[
  m ->e m' ==> \fn m \sim \fn m'
  \]
\end{lemma}

\begin{proof}\ \\
  Trivial (as if).
\end{proof}

\section{Generalisiation}
\fixme{Fatal: This doesn't hold! But it isn't too hard to fix. The problem is
  that generalising a pattern extends its domain: We can only do that when all
  following patterns are confused or shadowed.}

Sometimes patterns get unnecessary complex. If for example a pattern (or one of
its subpatterns) is a constructor pattern whose subpatterns are all variables,
and those variables are only used as arguments to the same constructor (in the
same order) in the function body, then the constructor could simply be replaced
by a fresh variable in pattern and body. That is generalisation of the pattern.

Sometimes the generalisation of a pattern makes it equivalent to another pattern
in the match. And sometimes the two patterns corresponding bodys will merge
seamlessly, such that two patterns can be made to one.
\\[1em]
First we need some auxiliary definitions.

\subsection{Partially ordered form}
\begin{definition}\ \\
  \label{def:part-order-form}
  A match $m = p_1\texttt{.}e_1\texttt{|}\ldots\texttt{|}p_n\texttt{.}e_n$ is in
  partially ordered form if
  \[
  \forall i \in \{1, \ldots, n\} : p_j \not <=' p_i \quad \textnormal{where $j > i$}
  \]
  Note that every match $m$ can be transformed to an equivalent match $m'$ such
  that $m'$ is in partially ordered form, by repeated elimination of shadowed
  patterns (\fref{sec:shadowed-patterns}).
\end{definition}

\subsection{Generalisation of patterns}
We define generalisation of a single pair of a pattern and its body. We write
$(p, e) |> (p', e')$ to mean that the pattern $p$ with its body $e$ generalises
to the pattern $p'$ with the body $e'$.

\begin{definition}[Generalisation of single pattern-body pairs, $|>$]\ \\
  \label{def:gener-patt}
  Inductively defined:
  \begin{eqnarray}
    (c \texttt{(} p_1 \texttt{,} \ldots \texttt{,} p_n \texttt{)} , e) &|>& (x , e[x
    / \kappa (c \texttt{(} p_1 \texttt{,} \ldots \texttt{,} p_n \texttt{)} )]) 
    \label{eq:single-gen-1}\\
    (c \texttt{(} p_1 \texttt{,} \ldots \texttt{,} p_i \texttt{,} \ldots
    \texttt{,} p_n \texttt{)}, e) &|>&
    (c \texttt{(} p_1 \texttt{,} \ldots \texttt{,} p'_i \texttt{,} \ldots
    \texttt{,} p_n \texttt{)}, e') \label{eq:single-gen-2}
  \end{eqnarray}
  Where \fref{eq:single-gen-1} holds when $x$ is a fresh variable and
  \[
  FV_{pat}(c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)}) \cap FV_{exp}(e[x/\kappa
  (c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)})]) = \emptyset
  \]
  and \fref{eq:single-gen-2} holds when \fref{eq:single-gen-1} does not and
  \[
  (p_i , e) |> (p'_i , e')
  \]
\end{definition}

\begin{lemma}\ \\
  \label{lem:single-gen-imp-gen}
  If a pattern $p$ (and some body) is generalised to $p'$ (and some other
  body), then $p'$ strictly generalises $p$. In other words
  \[
  (p, e) |> (p', e') ==> p <' p'.
  \]
\end{lemma}
\begin{proof}\ \\
  Straightforward induction proof.
\end{proof}

\begin{example}\ \\
  This example shows a match with an unnecessary complex pattern that reverses
  the components of a pair.

  \begin{eqnarray*}[c]
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Pair (Cons (x, xs), zs) . Pair (zs, Cons (x, xs))
\end{lstlisting}
    \end{eqnalign}
    |>
    \begin{eqnalign}[Tl]
\begin{lstlisting}
Pair (xs, zs) . Pair (zs, xs)
\end{lstlisting}
    \end{eqnalign}
  \end{eqnarray*}
\end{example}

\subsection{Generalisation of matches}
For the generalisation of a match $m$, we require $m$ to be in partially ordered
form.

When generalising a pattern several things might happen. Assume

\begin{eqnarray*}[rqTcql]
  m = p_1 \texttt{.} e_1 \texttt{|} \ldots \texttt{|} p_i \texttt{.} e_i
  \texttt{|} \ldots \texttt{|} p_n \texttt{.} e_n & and & (p_i, e_i) |> (p'_i,
  e'_i).
\end{eqnarray*}

 \fixme{n >= i >= 1?}

Now, perhaps $m$ can be generalised if we substitute $p'_i$ for $p_i$ and $e'_i$
for $e_i$. We would like the resulting match to be partially ordered too, so we
must be cautious. Since we know from \fref{lem:single-gen-imp-gen} that $p'_i >'
p_i$ the first part of the match $p_1 \texttt{.} e_1 \texttt{|} \ldots
\texttt{|} p'_i \texttt{.} e'_i$ must still be partially ordered. So we consider
the patterns $p_j$ for $j > i$.

Note that by \fref{lem:unique-rel} we know that either $p_i <' p_j$ or $p_i ||
p_j$ due to $m$ being on partially ordered form.

\paragraph{Generalisation scenarios} \ \\
Four scenarios arise
\begin{enumerate}
\item $p'_i$ and $p_j$ are equivalent. The pattern was generalised to one that
  already existed. Now the only hope is that $e'_i$ and $e_j$ merge. By this we
  mean $(p'_i, e'_i) ==a (p_j, e_j)$ (\Fref{def:alpha-equivalence-patexp}).

  If this is the case then either $p'_i \texttt{.} e'_i$ or $p_j \texttt{.} e_j$
  shall be removed. \label{item:gen-scen-1}
\item $p'_i$ relates to $p_j$ in the same way that $p_i$ does. So $p_i <' p_j
  \Rightarrow p'_i <' p_j$ and $p_i || p_j \Rightarrow p'_i || p_j$. In this
  case nothing must be done. \label{item:gen-scen-2}
\item $p_i || p_j$ and $p'_i >' p_j$. So now $p'_i$ ``steals'' $p_j$s input. But
  because $p_i$ and $p_j$ were confused we know that $p_j$ will not steal any
  input originally intended for $p_i$. So we move $p_j$ and its body up, in the
  match so they come before $p'_i$. \label{item:gen-scen-3}
\item $p_i <' p_j$ and $p'_i >' p_j$. This means that $p'_i$ will match input
  intended for $p_j$ but we can not move $p_j$ above $p'_i$ for then it will
  steal input originally intended for $p_i$. So in this case $m$ can not be
  generalised. \label{item:gen-scen-4}
\end{enumerate}

\begin{definition}[Generalisation, $->g$]\ \\
\label{def:gener-match}
  We define a reduction relation $->g$ that expresses the
  generalisation of exactly one pattern from a match.

  Let
  \begin{eqnarray*}[rqTcql]
    m = p_1 \texttt{.} e_1 \texttt{|} \ldots \texttt{|} p_i \texttt{.} e_i
    \texttt{|} \ldots \texttt{|} p_n \texttt{.} e_n & and & (p_i, e_i) |> (p'_i,
    e'_i).
  \end{eqnarray*}
  and assume that a generalisation as described above can be done. Then the
  resulting match is
  \begin{eqnarray*}[rclqqqTl]
    m' &=& p_1 \texttt{.} e_1 \texttt{|} \ldots \texttt{|} p_{i-1} \texttt{.}
    e_{i-1} & (Untouched)\label{eq:gen-1}\\
    &\texttt{|}& p_{m_1} \texttt{.} e_{m_1} \texttt{|} \ldots \texttt{|} p_{m_k}
    \texttt{.} e_{m_k} & (Scenario \ref{item:gen-scen-3})\label{eq:gen-2}\\
    (&\texttt{|}& p'_i \texttt{.} e'_i \ \ ) 
    & (Perhaps scenario \ref{item:gen-scen-1})\label{eq:gen-3}\\
    &\texttt{|}& p_{s_1} \texttt{.} e_{s_1} \texttt{|} \ldots \texttt{|} p_{s_l}
    \texttt{.} e_{s_l} & (Scenario \ref{item:gen-scen-2})\label{eq:gen-4}
  \end{eqnarray*}

  Where $m_1 < \ldots < m_k$ and $s_1 < \ldots < s_l$.

  The third line is put in parentheses because it should be deleted in the case
  of scenario \ref{item:gen-scen-1}.

  And we write $m ->g m'$.

  \begin{lemma}\ \\
    If $m ->g m'$ then $m'$ is in partially ordered form.
  \end{lemma}
  \begin{proof}\ \\
    Assume
    \begin{eqnarray*}[rqTcql]
      m = p_1 \texttt{.} e_1 \texttt{|} \ldots \texttt{|} p_i \texttt{.} e_i
      \texttt{|} \ldots \texttt{|} p_n \texttt{.} e_n & and & (p_i, e_i) |> (p'_i,
      e'_i).
    \end{eqnarray*}

    Since every $p_j <' p'_i$ for $j > i$ is moved in front of $p'_i$ the only
    thing that can break the partial ordering of $m'$ is if $p_j <' p_k$ for
    $i < j < k$ and $p_k$ moves, but $p_j$ does not. For this to happen $p_j$
    must fall into scenario \ref{item:gen-scen-2} and $p_k$ must fall into
    scenario \ref{item:gen-scen-3}.

    Either $p'_i <' p_j$ or $p'_i || p_j$. In the first case we have by
    transitivity that $p'_i <' p_k$, so $p_k$ can not fall into category
    \ref{item:gen-scen-3}, which is a contradiction.

    In the latter case we have by assumption that $p'_i || p_j$ and $p_k <'
    p'_i$. But then we get by lemma \fref{lem:more-specific-confused} that $p_k
    || p_j$, which is a contradiction.
  \end{proof}

\end{definition}

\begin{example}[Generalisation, $->g$]\ \\
Assume that the constructor environment is $C = \{list \mapsto \{\mathtt{Cons},
\mathtt{Nil} \}, pair \mapsto \{\mathtt{Pair}\} \}$ which maps data types into ,
and that there exists a function \texttt{+}. \fixme{Do this right according to
  the new environment definitions}

Consider

\begin{sml}
val rec addodd = 
fn Cons (Cons (Pair (a, b), Pair (c, d)), xs) .
     Cons (Cons (Pair (a, b), + (Pair (c, d))), addodd xs)
 | Cons (Pair (a, b), Nil) . Cons (Pair (a, b), Nil)
 | Nil . Nil
 | x . x
\end{sml}

As the match is not in partially ordered form (due to the pattern \texttt{x})
our only choice is to eliminate. Luckily we can, because the three first
patterns forms a cover, so we can eliminate the fourth. We get
\begin{sml}
val rec addodd = 
fn Cons (Cons (Pair (a, b), Pair (c, d)), xs) .
     Cons (Cons (Pair (a, b), + (Pair (c, d))), addodd xs)
 | Cons (Pair (a, b), Nil) . Cons (Pair (a, b), Nil)
 | Nil . Nil
\end{sml}
which is in partially ordered form. The second clause can be generalised to
\smlinline{x . x}. This means that the clause \smlinline{Nil . Nil} should be moved
up. We get
\begin{sml}
val rec addodd = 
fn Cons (Cons (Pair (a, b), Pair (c, d)), xs) .
     Cons (Cons (Pair (a, b), + (Pair (c, d))), addodd xs)
 | Nil . Nil
 | x . x
\end{sml}
Next we can generalise \smlinline{Nil . Nil} to \smlinline{x . x} which coincide with
the third clause, so we remove it.
\begin{sml}
val rec addodd = 
fn Cons (Cons (Pair (a, b), Pair (c, d)), xs) .
     Cons (Cons (Pair (a, b), + (Pair (c, d))), addodd xs)
 | x . x
\end{sml}
The first clause can be generalised to

\begin{sml}
Cons (Cons (x, y), xs) . Cons (Cons (x, + y), addodd xs)
\end{sml}
\noindent (by generalising the two \texttt{Pair} patterns), so we get

\begin{sml}
val rec addodd = 
fn Cons (Cons (x, y), xs) .
     Cons (Cons (x, + y), addodd xs)
 | x . x
\end{sml}
which cannot be generalised or eliminated upon. So it is a normal form.

\end{example}

\section{Normal form}
We say that the function $\fn m$ is a normal form if there does not exist an
$m'$ such that $m ->e m'$ or $m ->g m'$.

\subsection{Reducing to normal form}
Consider a function $\fn m$. It can be converted to a normal form by repeatedly
eliminating and generalising patterns.

Note that $m$ should be in partially ordered form (\fref{def:part-order-form}) in
order to generalise its patterns. Luckily we can convert it to a partially
ordered form by repeated elimination.

\begin{lemma}\ \\
  If a function $f$ can be converted to the normal form $f'$, then $f$ and $f'$
  are semantically equivalent.
\end{lemma}

\begin{lemma}\ \\
  We expect the normal form to be unique (in some sense).
\end{lemma}

\begin{example}\ \\
Consider 
\begin{sml}
val f = 
fn A (A (a, b), c) . A (c, A (a, b))
 | A (a, b)        . A (b, a)
 | B               . B
 | x               . x
 | A (a, A (b, c))  . A (A (c, b), a)
\end{sml}
Assume that the only constructors are \texttt{A} and \texttt{B}.

As the match is not in partially ordered form (due to the last pattern being
more specific than the pattern \texttt{x}) our only choice is to
eliminate. Luckily we can, because the four (three actually) first patterns
forms a cover. With the last clause eliminated we have

\begin{sml}
val f = 
fn A (A (a, b), c) . A (c, A (a, b))
 | A (a, b)        . A (b, a)
 | B               . B
 | x               . x
\end{sml}

From here we can choose to eliminate or generalise. We generalise and it is the
case that
\[
(\texttt{A (A (a, b), c)}, \texttt{A (c, A (a, b))}) |> (\texttt{A (x, y)},
\texttt{A (y, x)})
\]

We arrive at generalisation scenario \ref{item:gen-scen-1} since $\texttt{A (a, b)} ==
\texttt{A (x, y)}$. So we must have 
\[ 
(\texttt{A (a, b)}, \texttt{A (b, a)}) 
==a (\texttt{A (x, y)}, \texttt{A (y, x)})
\]
which is the case. So the first clause can be deleted. We now have

\begin{sml}
val f = 
fn A (a, b) . A (b, a)
 | B        . B
 | x        . x
\end{sml}

Since the two first patterns form a cover the last clause can be eliminated. We
end up with

\begin{sml}
val f = 
fn A (a, b) . A (b, a)
 | B        . B
\end{sml}

which cannot be generalised or eliminated further, so it is a normal form.
\end{example}


\section{Weak unification}
\fixme{To do or not to do?}



%%% Local Variables: 
%%% mode: latex
%%% reftex-fref-is-default: t
%%% TeX-master: "../report"
%%% End: 
