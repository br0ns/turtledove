\chapter{Normal form}

In this chapter we will present the definition of a normal form of functions in
a language weary similar to SML and how to derive it from any well-formed code
in this language. The language presented below is untyped for simplicity, but
obviously when the techniques are transfered to a language with types, the code
must not only be well-formed but also well-typed.

In the end we will give an informal argument of how this can be directly
transfered to work on any well-formed and well-typed SML program.

\input{sml-normalform/normalform}

\section{Extension to SML}

We have shown what we mean by a functions normal form and -- more or less -- how
to compute it.

Now we consider the challenges in extending the work to SML. Here we list the
main differences between our toy language and SML.

\begin{enumerate}
\item SML is a much bigger language. This has no real implication on the
  theoretical aspect but it does add a lot of bulk to an implementation. In
  particular one has to consider rebinding of variables, modules, data type
  declarations, type specification, unnecessary parenthesis, etc.
\item There are many more forms of expressions in SML. Again this has no real
  theoretical implication safe one thing: the \texttt{let}-construct. The
  problem is that the order of declarations, and even whether to have them or
  not, is arbitrary to some extend. One way around this could be elimination of
  \texttt{let}-expressions by inlining of non-recursive value declarations and
  lifting of recursive ones (that is functions) to an outer scope (by inserting
  a \texttt{local}-block one can avoid polluting the environment). We have not
  pursued this idea in practice.
\item Syntactic sugar in SML means that there is different syntax for the same
  thing. One solution is to remove the syntactic sugar before conversion to
  normal form. Another is to handle syntactic sugar specially. See
  \fref{sec:preparation} below.
\item In SML all constructors are nullary or unary. This has no significance in
  itself. On the other hand SML has tuples and records which do present a
  challenge.
\item SML has records and tuples. See \fref[plain]{sec:algorithm} below.
\item In SML there is no $\kappa$-function. See \fref[plain]{sec:preparation}
  below.
\end{enumerate}

\subsection{Preparation}\label{sec:preparation}
Before we can compute a match's normal form we need to make some
preparations. In particular we eliminate some forms of syntactic sugar and
transforms patterns to a subset of the expressions, in order to have the
$\kappa$-function defined.

\subsection{Algorithm}\label{sec:algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
