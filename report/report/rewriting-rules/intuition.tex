\section{Intuition}
In this section we will try to give an intuitive understanding of the rules
given in the previous section, and why we have made them the way they are.

\subsection{Scheme patterns, contexts and meta patterns}
The $\sigma$-environment binds variables of the form $\mathcal{C}$ to meta
patterns with zero or more holes. They can be thought of as contexts since other
(hole free) meta patterns can inhabit the holes. A (variable denoting a) meta
pattern applied to as many hole free meta patterns as it has holes is called a
context. If $\sigma(\mathcal{C}) = \diamond_1\ \ttt{::}\ \ol{ys}$ then --- as an
example --- this is a context:
\[
\mathcal{C}[\ttt{SOME}\ \ol{a}]
\]

Scheme patterns are patterns over contexts and meta variables. So with the same
$\sigma$ as above this could be a scheme pattern:
\[
\ttt{($\ol{a}$, $\mathcal{C}[\ol{y}]$)}
\]

Meta patterns can be instantiated to concrete SML patterns in which case the
pattern variables are bound to subpatterns of the SML pattern. Consider the SML
pattern
\begin{sml}
((a, b), x :: y :: xs)
\end{sml}
recall that \ttt{::} is right associative. Thus the resulting tree is this:
\begin{center}
\begin{tikzpicture}[]
  \node (outer-pair)                               {\smlinline{(, )}};
  \node (dummy)      [below right of = outer-pair] {};
  \node (inner-pair) [below left of = outer-pair]  {\smlinline{(, )}};
  \node (A)          [below left of = inner-pair]  {\smlinline{a}};
  \node (B)          [below right of = inner-pair] {\smlinline{b}};
  \node (fst-cons)   [right of = dummy]            {\smlinline{::}};
  \node (snd-cons)   [below right of = fst-cons]   {\smlinline{::}};
  \node (X)          [below left of = fst-cons]    {\smlinline{x}};
  \node (Y)          [below left of = snd-cons]    {\smlinline{y}};
  \node (XS)         [below right of = snd-cons]   {\smlinline{xs}};
  \path (outer-pair) edge (inner-pair)
        (outer-pair) edge (fst-cons)

        (inner-pair) edge (A)
        (inner-pair) edge (B)

        (fst-cons) edge (X)
        (fst-cons) edge (snd-cons)

        (snd-cons) edge (Y)
        (snd-cons) edge (XS);
\end{tikzpicture}
\end{center}

First a scheme pattern is turned into a meta pattern under the environment
$\sigma$. With the same $\sigma$ as above we would have
\[
\inference
{
  \inference
  {}
  {
    \subspat
    {\sigma}
    {\ol{a}}
    {\ol{a}}
  } &
  \inference
  {}
  {
    \subspat
    {\sigma}
    {\mathcal{C}[\ol{y}]}
    {(\diamond_1\ \ttt{::}\ \ol{ys})[\ol{y}/\diamond_1]}
  }
}
{
  \subspat
  {\sigma}
  {\ttt{($\ol{a}$, $\mathcal{C}[\ol{y}]$)}}
  {\ttt{($\ol{a}$, $\ol{y}\ $::$\ \ol{ys}$)}}
}
\]
and then

\begin{narrow}{-5em}{0em}
\[
\inference
{
  \inference
  {}
  {
    \matchpat
    {\mathsml{(a, b)}}
    {\ol{a}}
    {
      \left\{
        \ol{a} \mapsto \mathsml{(a, b)}
      \right\}
    }
  } &
  \inference
  {
    \inference
    {}
    {
      \matchpat
      {\mathsml{x}}
      {\ol{y}}
      {
        \left\{
          \ol{y} \mapsto \mathsml{x}
        \right\}
      }
    } &
    \inference
    {}
    {
      \matchpat
      {\mathsml{y :: xs}}
      {\ol{ys}}
      {
        \left\{
          \ol{ys} \mapsto \mathsml{y :: xs}
        \right\}
      }
    }
  }
  {
    \matchpat
    {\mathsml{x :: y :: xs}}
    {\ttt{$\ol{y}\ $::$\ \ol{ys}$}}
    {
      \left\{
        \begin{tabular}{Mc@{$\ \mapsto\ $}Mr}
          \ol{y} & \ttt{x}\\
          \ol{ys} & \mathsml{y :: xs}
        \end{tabular}
      \right\}
    }
  }
}
{
  \matchpat
  {\mathsml{((a, b), x :: y :: xs)}}
  {\ttt{($\ol{a}$, $\ol{y}\ $::$\ \ol{ys}$)}}
  {
    \left\{
      \begin{tabular}{Mc@{$\ \mapsto\ $}Mr}
        \ol{a} & \ttt{(a, b)}\\
        \ol{y} & \ttt{x}\\
        \ol{ys} & \mathsml{y :: xs}
      \end{tabular}
    \right\}
  }
}
\]
\end{narrow}

In this case we get
\[
\theta =
\left\{
  \begin{tabular}{Mc@{$\ \mapsto\ $}Mr}
    \ol{a} & \ttt{(a, b)}\\
    \ol{y} & \ttt{x}\\
    \ol{ys} & \mathsml{y :: xs}
  \end{tabular}
\right\}
\]

\subsection{Transformers}
In the bodies of scheme clauses, eg. scheme expressions, we want to express that
\textit{some} computation takes place without being too specific about
\textit{what} it actually is. We use transformers to that end.

A transformer is simply a pair of a (concrete) SML pattern and an SML
expression. On can think of it as a single clause, or a function definition
without the benefits of pattern matching.

Consider the function definition
\begin{sml}
fun foo ((a, b) :: xs) = f (b, a) :: foo xs
  | foo nil            = nil
\end{sml}
It is an obvious target for at \textsf{map}-rule. During rewriting we would get
a $\theta$ that binds a variable to \smlinline{(a, b)}. Now we need to express
the relationship between \smlinline{(a, b)} and \smlinline{f (b, a)}. We do that
simply by storing the pattern and the expression.

\subsection{The ``\textsf{self}'' keyword}

\subsection{Schemes}
Schemes are lists of scheme clauses. A scheme clause is essentially a pair of a
scheme pattern and a scheme expression written as
\[
spat => sexp
\]
A concrete SML clause can be an instance of a scheme clause under a particular
$\sigma$-environment. The $\theta$-environment is build on an per clause basis
as we saw above. Let
\[
\sigma =
\left\{
  \begin{tabular}{Mc@{$\ \mapsto\ $}Mr}
    \mathcal{C} & \diamond_1\\
    \mathbb{E} & (\ttt{(v, w)}, \ttt{w + v})\\
    \textsf{self} & (\ttt{foo}, 1)
  \end{tabular}
\right\}
\]
Consider the SML clauses
\begin{eqnarray*}[ll]
  \mathsml{(a, b) :: xs}\ttt{ }&\mathsml{= b + a :: foo xs}\\
  \mathsml{nil}\ttt{ }&\mathsml{= nil}
\end{eqnarray*}
and the scheme clauses
\begin{eqnarray*}[lcl]
  \mathcal{C}[\ol{x}\ \ttt{::}\ \ol{xs}] &=&
\mathbb{E}(\mathcal{C}[\ol{x}])\ \ttt{::}\ \textsf{self}(\mathcal{C}[\ol{xs}])\\
\mathcal{C}[\ttt{nil}] &=& \ttt{nil}
\end{eqnarray*}
Instantiating the meta patterns we get
\[
\inference
{}
{
  \subspat
  {\sigma}
  {\mathcal{C}[\ol{x}\ \ttt{::}\ \ol{xs}]}
  {\ttt{$\ol{x}$\ \ttt{::}\ $\ol{xs}$}}
}
\quad \textrm{and} \quad
\inference
{}
{
  \subspat
  {\sigma}
  {\mathcal{C}[\ttt{nil}]}
  {\ttt{nil}}
}
\]
We see that the SML patterns are instances of the meta patterns:
\[
\inference
{\vdots}
{
  \matchpat
  {\mathsml{(a, b) :: xs}}
  {\ttt{$\ol{x}$\ \ttt{::}\ $\ol{xs}$}}
  {\theta_1}
}
\quad \textrm{and} \quad
\inference
{\vdots}
{
  \matchpat
  {\mathsml{nil}}
  {\ttt{nil}}
  {\theta_2}
}
\]
where
\[
\theta_1 =
    \left\{
      \begin{tabular}{Mc@{$\ \mapsto\ $}Mr}
        \ol{x} & \ttt{(a, b)}\\
        \ol{xs} & \ttt{xs}
      \end{tabular}
    \right\}
    \ , \quad
\theta_2 = \{\}
\]
And finally we can see that the SML bodies are instances of the scheme ditto:
\[
\inference
{
  \inference
  {
    \inference
    {
      \inference
      {
        \inference
        {}
        {
          \matchbody
          {\sigma}
          {\theta_1}
          {\ol{x}}
          {\ttt{(a, b)}}
        }
      }
      {
        \matchbody
        {\sigma}
        {\theta_1}
        {\diamond_1[\ol{x}/\diamond_1]}
        {\ttt{(a, b)}}
      }
    }
    {
      \matchbody
      {\sigma}
      {\theta_1}
      {\mathcal{C}[\ol{x}]}
      {\mathsml{(a, b)}}
    }
  }
  {
    \matchbody
    {\sigma}
    {\theta_1}
    {\mathbb{E}(\mathcal{C}[\ol{x}])}
    {(\mathsml{w + v})[\mathsml{(a, b)}/\mathsml{(v, w)}]}
  } &
  \inference
  {
    \inference
    {
      \inference
      {
        \inference
        {}
        {
          \matchbody
          {\sigma}
          {\theta_1}
          {\ol{xs}}
          {\ttt{xs}}
        }
      }
      {
        \matchbody
        {\sigma}
        {\theta_1}
        {\diamond_1[\ol{xs}/\diamond_1]}
        {\ttt{xs}}
      }
    }
    {
      \matchbody
      {\sigma}
      {\theta_1}
      {\mathcal{C}[\ol{xs}]}
      {\mathsml{xs}}
    }
  }
  {
    \matchbody
    {\sigma}
    {\theta_1}
    {\textsf{self}(\mathcal{C}[\ol{xs}])}
    {(\mathsml{foo x})[\mathsml{xs}/\mathsml{x}]}
  }
}
{
  \matchbody
  {\sigma}
  {\theta_1}
  {
    \mathbb{E}(\mathcal{C}[\ol{x}])\ \ttt{::}\
    \textsf{self}(\mathcal{C}[\ol{xs}])
  }
  {
    \mathsml{b + a :: foo xs}
  }
}
\]
and
\[
\inference
{}
{
  \matchbody
  {\sigma}
  {\theta_2}
  {\ttt{nil}}
  {\ttt{nil}}
}
\]

\subsection{The $\sigma$-environment}

% \subsection{Rewriting rules}

% \fixme{This is utterly wrong.}
% \fixme{Reference to the definition}


% A rewriting rule is defined from the clauses of the function that it must match,
% thus it doesn't define any meta information such as the functions name. However
% to be able to match recursive functions we introduce the keyword \textsf{self}
% as a placeholder for the name of the function that is being matched.

% \fixme{Her kommer normalformen på noget af en opgave, men det ser ud til at
%   virke. Tjek det!}

% A rule may match partially in the sense that if the clauses $n$ through $n+1$ of
% a function is an instance of a rule with $i$ schemes, then the rewriting may still be
% done for those specific clauses.

% \fixme{example hereof}

% \fixme{This might be broken up and then the canonical instantiation may be brought
%   up and the rest of the text below in a subsubsection}. 

% % subsubsection{simplicity of the syntax and why it looks as it does}

% \fixme{Most of the below is more aimed at the schemes}

% We can use the same rule syntax for both curried and uncurried functions by not
% expressing more information about the function or its parameters in the rule.

% It might be remembered that the curried function below

% \begin{sml}
% fun add n nil       = nil
%   | add n (x :: xs) = n + x :: add n xs
% \end{sml}

% is desugared (in multiple steps) to

% \begin{sml}
% val rec add = fn n => 
%               fn xs => (fn (n, nil) => nil
%                          | (n, x::xs) => n + x :: add n xs) (n, xs)
% \end{sml} 

% and the same uncurried function 

% \begin{sml}
% fun add' (n, nil)     = nil
%   | add' (n, x :: Xs) = n + x :: add' (n, xs)
% \end{sml}

% becomes

% \begin{sml}
% val rec add' = fn (n, nil) = []
%                 | (n, x::xs) = n + x :: add' (n, xs)
% \end{sml}

               

% As it is seen, both cases end up with an anonymous function. If there are more
% than one then only the inner most is of interest as this anonymous
% function gets the two arguments as a tuple. This anonymous function has a number
% of clauses with pattern and body which match that of the original function

% We have chosen to define our schemes in such a way that they look similar to the
% above. Alle clauses in a scheme starts on $|$ (which except for the first clause
% also apply for SML), since we have partial matching and thus don't know if the
% the first function clause will match the first scheme clause.

% We believe this makes up the most natural way of expressing schemes that will
% match SML and thus a scheme is a list of $n$ scheme clauses

% \begin{eqnarray*}[rqrl]
% | & spat_1 & => sexp_1 \\
%   &  & \vdots \\
% | & spat_n & => sexp_n
% \end{eqnarray*}

% where $spat_n$ is a scheme pattern and $sexp_n$ is a scheme expression.

% \fixme{Der beskrives slet ikke hvordan og hvorledes med resultat
%   omskrivningen. Der beskrives kun den matchende del af skabelonen.}

\subsection{Relations on meta patterns (the $\rho$-environment)}

% \fixme{This is a lot of ideas of what we might need. It should be more concrete}

% We express restrictions on a scheme with the keyword \textsf{where} followed by
% the restrictions \fixme{insert ref to the syntax definition}. 

% As we saw in the \textsf{map} example above it may be necessary to introduce
% restrictions on some of the meta patterns as a function of others, such as
% $dom$.

% Predicates and functions over expressions (and with extension over meta
% functions) \fixme{why over metafunctions?} might come in handy, such as a
% predicate that may determine whether an expression has side effects.

% blabla....

% Metafunktionerne implementeres nok kønnest ``uden for''
% omskrivningssystemet. F.eks. omformes erklæringer til normalform før de
% forsøges omskrevet, og man kunne forestille sig et forsimplingstrin
% efterfølgende (eta-reduktion vil være ret nyttigt). Andre ting som
% \texttt{let}-løftning bør også overvejes.

% Bemærk at metafunktionerne kan have en nytteværdi i sig selv, og ikke blot
% sammen med omskrivningssystemet.

\subsection{Example}

% Introduction...

% \begin{example}[Matching / use of pattern variables] \
% \label{ex:intuition-example}

%   \fixme{Find ordenligt eksempel navn/tekst}

%   \fixme{this example uses dom. Rearrange the text so dom is explained before}

%   \fixme{add reference to the map rule definition, instead of hiding that this
%     is a map example.}
  
%   Given the below function \texttt{foo}, we will try and match it up with the
%   \textsf{map}-rule

% \begin{sml}
% fun foo (a, b :: xs) = b + a
%   | foo _            = 0
% \end{sml}

%   The first clause in \texttt{foo} is an instance of the first
%   scheme in the \textsf{map}-rule

%   \[
%   |\ \mathcal{C}[\overline{x}\texttt{ :: }\overline{xs}] =>
%   \mathbb{D}(\mathcal{C}[\overline{x}])
%   \]

%   with

%   \begin{eqnarray*}[rl]
%     \mathcal{C} &\mapsto \texttt{(}\overline{y}\texttt{,} \diamond\texttt{)}\\
%     \overline{a} &\mapsto \texttt{a}\\
%     \overline{x} &\mapsto \texttt{b}\\
%     \overline{xs} &\mapsto \texttt{xs}\\
%     \mathbb{D}(\texttt{(}\overline{a}\texttt{,} \overline{b}\texttt{)}) &=
%     \kappa(\overline{b}) \texttt{ + } \kappa(\overline{a})
%   \end{eqnarray*}

%   The second clause is an instance of the scheme

%   \[
%   |\ \mathcal{D} => \mathbb{E}(\mathcal{D})
%   \]

%   with

%   \begin{eqnarray*}[rl]
%     \mathcal{D} &\mapsto \overline{a}\\
%     \overline{a} &\mapsto \texttt{\_}\\
%     \mathbb{E}(\overline{a}) &= \texttt{0}
%   \end{eqnarray*}
  
%   Finally, if $dom(\lfloor\mathcal{D}\rfloor) =
%   dom(\lfloor\mathcal{C[\texttt{\_}]}\rfloor)$, which is the case here, then the
%   function \texttt{foo} is an instance of the $\mathsf{map}$-rule and may be
%   rewritten accordingly:

%   \fixme{maybe some more text about the dom}

%   \begin{eqnarray*}[c]
%     \texttt{fun foo $\lfloor \mathcal{C} \rfloor [\lfloor xs \rfloor]$ = map (fn $x$ =>
%       $\mathbb{D}(\lfloor \mathcal{C} \rfloor[\lfloor x \rfloor])$) $\lfloor xs
%       \rfloor$}\\
%     =\\
%     \texttt{fun foo (a, b) = map (fn b => b + a) b}
%   \end{eqnarray*}
  
%   We have explicitly written the canonical instantiation, but as noted before
%   this will not always be done.
% \end{example}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
