\section{Fold}

\begin{example}
  In the 2008 exam set, the students were asked to implement a \ttt{composelist}
  function which given a list of functions $[f_1, f_2, \ldots, f_n]$ and a value
  $v$ would compute the result of $f_1(f_2(\ldots(f_n(v))))$.

  We saw that this assignment gave rise for two solutions below that would be
  desirable to rewrite. The below is student code, hence the questionable choice
  of variables in function \#2.

  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Original Function \#1}
      & 
      \textbf{Normalised Function \#1}
      \\\hline
\begin{sml}
fun composelist [] x = x 
  | composelist (f :: []) x = f(x) 
  | composelist (f :: fs) x = 
      f(composelist fs x)
\end{sml}
      &
\begin{sml}
fun composelist (f :: []) x = f (x)
  | composelist (f :: fs) x = 
      f (composelist fs x)
  | composelist y x = x        
\end{sml}
      \\\hline
      \textbf{Original Function \#2}
      &
      \textbf{Normalised Function \#2}
      \\\hline
\begin{sml}
fun composelist [] x = x 
  | composelist (y::ys) x = 
     y (composelist (ys) x)
\end{sml}
      &
\begin{sml}
fun composelist (y :: ys) x = 
      y (composelist (ys) x)
  | composelist y x = x
\end{sml}
      \\\hline
    \end{tabular}
  \end{center}

  \noindent
  The first version of the \ttt{composelist} function can't be matched by the
  any of the \tsf{fold}-rules\footnote{Obviously a rule could be made that would
    match, but that would kind of defeat the purpose of the system. It should be
    general enough such that as few rules as possible ought to be defined.} as
  it has the extra clause trying to specially handle the case where there is
  exactly one element in the list, which is a typical novice mistake, not to see
  that the two clauses can be joined (see XXX \fixme{ref to the unification} for
  why we can't do anything about this).

  There were (luckily) only a small number that used the first approach whereas
  the second approach was the main way of solving the assignment besides using a
  right fold.

  As the first approach can't be rewritten with the current rules, we will
  disregard it in this example and only rewrite the second.
  \\

  \noindent
  We have the following scheme instance of the \textsf{foldr} rule for the
  normalised \ttt{composelist} function \#2
  
  \begin{center}
    \begin{tabular}{c | Mr @{} Ml Mr @{} Ml Mr @{} Ml !{\hspace{3em}} Mr @{} Ml}
      \textbf{Clause} 
      & \multicolumn{6}{c !{\hspace{3em}}}{\textbf{Metapatterns/-variables}}
      & \multicolumn{2}{c}{\textbf{Transformers}} 
      \\ \hline
      \#1
      &\mathcal{C} \mathrel{} & \mapsto (\diamond, \ttt{x})
      & \ol{x} \mathrel{} & \mapsto \ttt{y} 
      & \ol{xs} \mathrel{} & \mapsto \ttt{ys} 
      & \mathbb{D}\ ((a,b),\ x) \mathrel{} & = a\ (x)
      \\
      % same clause
      & \ttt{self} \mathrel{} & \mapsto \ttt{composelist}
      &&
      &&
      &&
      \\ \hline
      \#2
      & \mathcal{D} \mathrel{} & \mapsto \ttt{(y, x)}
      &&
      && 
      & \mathbb{E}\ (a,\ b) \mathrel{} & \mapsto b
      \\
    \end{tabular}
  \end{center}
  
  \noindent
  and thus it can be rewritten with the following
 
  \begin{eqnarray*}[c]
    \mathcal{C}[\ol{xs}] -> \mathcal{C}[\ttt{ys}] -> (\ttt{ys},\ \ttt{x})
    \qquad\quad
    \mathcal{C}[\ttt{a}] -> (\ttt{a},\ \ttt{x})
    \\
    \mathbb{D}((\ttt{a},\ \ttt{x}),\ \ttt{b}) -> a (b)
    \qquad\quad
    \mathbb{E} \ttt{(y, x)} -> \ttt{x}
  \end{eqnarray*}
  
  \noindent
  to

  \begin{center}
    \begin{tabular}{|l|}
      \hline
      \textbf{Rewritten function} \\ \hline
      \begin{sml}
fun composelist ys x = foldr (fn (a,b) => a b) (x) ys
      \end{sml} \\ \hline
    \end{tabular}
  \end{center}

\end{example}




\begin{example}
  In the 2009 exam set the students were asked to rewrite the \ttt{sumlige}
  function using higher order functions.

  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Original Function}
      & 
      \textbf{Normalised Function}
      \\\hline
  \begin{sml}
fun sumlige [] = 0
  | sumlige (x :: xs) = 
      if x mod 2 = 0 
      then x div 2 + sumlige xs 
      else sumlige xs     
  \end{sml}
      &
      \fixme{insert normalised function}
      \\\hline
    \end{tabular}
  \end{center}

  \fixme[inline, margin=false]{Insert rest of example when foldl rule is made}

\end{example}



\begin{example}[\textsf{fold}-instans]\
\begin{sml}
fun sum nil       = 0
  | sum (x :: xs) = sum xs + x
\end{sml}

normaliseres til

\begin{sml}
fun sum (x :: xs) = sum xs + x
  | sum _         = 0
\end{sml}

De to klausuler er en instans af \textsf{foldl}-reglen med

\begin{eqnarray*}[rl]
  \mathcal{C} &\mapsto \diamond\\
  \overline{x} &\mapsto \texttt{x}\\
  \overline{xs} &\mapsto \texttt{xs}\\
  \mathbb{D}(\texttt{($\overline{a}$, $\overline{b}$)}) &=
  \kappa(\overline{b}) \texttt{ + } \kappa(\overline{a})\\
  \mathcal{D} &\mapsto \texttt{\_}\\
  \mathbb{E}(\overline{a}) &= \texttt{0}
\end{eqnarray*}

Så de skrives om til
  \begin{eqnarray*}[c]
    \texttt{$\mathcal{C}[xs]$ => foldl (fn ($a$, $b$) =>
      $\mathbb{D}($($\mathcal{C}[a]$, $b$)$)$) $\mathbb{E}(\mathcal{C}[$nil$])$
      $xs$}\\
    =\\
    \texttt{a => foldl (fn (a, b) => b + a) 0 a}
  \end{eqnarray*}

Og det endelige resultat er

\begin{sml}
fun sum a = foldl (fn (a, b) => b + a) 0 a
\end{sml}


  % \begin{eqnarray*}
  %   (y::ys) &=>& y + \mathtt{self} \left( ys \right) \\
  %   nil &=>& 0
  % \end{eqnarray*}

  % Hvilket er normaliseret så det bliver ikke omskrevet.

  % \begin{enumerate}
  % \item Antal klausuler matcher.

  % \item 

  % \item $\mathcal{C}$ instantieres til $\diamond$ og $\mathcal{G} = 0$

  %   \begin{description}
  %   \item[Klausul 1] $\overline{x} \mapsto y, \overline{xs} \mapsto ys$
      
  %   \item[Klausul 2] $\overline{x} \mapsto nil$
  %   \end{description}
    
    
  % \item $\mathbb{D}(\overline{n}, \overline{m}) = \kappa(\overline{n}) +
  %   \kappa(\overline{m})$
  % \end{enumerate}

  % Vi kan derfor anvende denne skabelon og lave omskrivningen, hvor der haves
  % $\floor{\mathcal{C}} = \diamond, \floor{\mathcal{G}} = 0$

  % \begin{eqnarray*}[c]
  %    \floor{\mathcal{C}} [xs]  => \textsf{fold } \left( \textsf{fn } (a,b) =>
  %     \mathbb{D}\left( \floor{\mathcal{C}}[a],\ b \right) \right) \
  %   \floor{\mathcal{G}} \ xs \\
  %   %
  %   \Downarrow \\
  %   % 
  %   xs => \textsf{fold } \left( \textsf{fn } (a,b) => a+b
  %   \right) \ 0 \ xs
  % \end{eqnarray*}
  
\end{example}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
