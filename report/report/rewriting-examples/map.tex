\section{Map}

\begin{example}[Simple \textsf{map}-instance]\


  \begin{center}
    \begin{tabular}{|l|l|}
      \hline \textbf{Original function} & \textbf{Normalised function}\\ \hline
\begin{sml}
fun foo nil       = nil
  | foo (x :: xs) = x + 1 :: foo xs
\end{sml}
      &
\begin{sml}
fun foo (x :: xs) = x + 1 :: foo xs
  | foo _         = nil
\end{sml}
      \\ \hline
    \end{tabular}
  \end{center}

\noindent
There is not much the normalisation changes here other than the order of the
clauses as \ttt{x :: xs} is more specific than \ttt{nil}

We have the following scheme instance of the \textsf{map} rule for the
normalised \ttt{foo} function

\begin{center}
  \begin{tabular}{c | Mr @{} Ml Mr @{} Ml Mr @{} Ml Mr @{} Ml}
    \textbf{Clause} 
    & \multicolumn{6}{c}{\textbf{Metapatterns}}
    & \multicolumn{2}{c}{\textbf{Transformers}} 
    \\ \hline
    \#1
    &\mathcal{C} \mathrel{} & \mapsto \diamond 
    & \ol{x} \mathrel{} & \mapsto \ttt{x} 
    & \ol{xs} \mathrel{} & \ttt{xs} 
    & \mathbb{D}\ \ol{a} \mathrel{} & = \ttt{$\kappa(\ol{a})$ + 1}
    \\
    % same clause
    & \ttt{self} \mathrel{} & \mapsto \ttt{foo}
    &&
    &&
    &&
    \\ \hline
    \#2
    & \mathcal{D} \mathrel{} & \mapsto \ttt{nil}
    &&
    && 
    &&
    \\
  \end{tabular}
\end{center}

\noindent
and thus it can be rewritten with the following

\begin{center}
  \begin{tabular}{Ml Ml}
    \mathcal{C}[\ol{xs}]  == \mathcal{C}[\ttt{xs}] == \kappa{(\ttt{xs})} == \ttt{xs}
    & \mathcal{C}[\ol{m}] == \kappa{(\ol{m})} == \ttt{a}^{(\dag)} 
    \\ \mathbb{D}\ \ttt{a} == \ttt{a + 1} & \\    
  \end{tabular} \\
  \small{$(\dag)$} for \ttt{a} being a free variable in the environment
\end{center}

\noindent
to

\begin{center}
  \begin{tabular}{|l|}
    \hline
    \textbf{Rewritten function} \\ \hline
  \begin{sml}
fun foo xs = map (fn a => a + 1) xs
  \end{sml} \\ \hline
\end{tabular}

\end{center}

\end{example}



\begin{example}
  One of the discarded assignments from 2008 was:

fun mapfil (f, p, []) = []
  | mapfil (f, p, (x::xs)) = (if p x then f x else x) :: mapfil(f, p, xs)



fun mapfil (f,p,xs) => map (fn a => if p a then f a else a) xs

\end{example}


\begin{example}
eks 2009
  \begin{sml}
fun collatz [] = []
  | collatz (x :: xs) = if x mod 2 = 0 then 
                          x div 2 :: collatz xs
                        else 
                          3*x + 1 :: collatz xs
  \end{sml}

\end{example}
group assignment 4 2010
\begin{example}
  \begin{sml}
fun evallist [] v      = []
  | evallist (f::fs) v = f v :: evallist fs v    
  \end{sml}
\end{example}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
