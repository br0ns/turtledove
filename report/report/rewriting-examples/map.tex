\section{Map}

\begin{example}[Simple \textsf{map}-instance]\


  \begin{center}
    \begin{tabular}{|l|l|}
      \hline \textbf{Original function} & \textbf{Normalised function}\\ \hline
\begin{sml}
fun foo nil       = nil
  | foo (x :: xs) = x + 1 :: foo xs
\end{sml}
      &
\begin{sml}
fun foo (x :: xs) = x + 1 :: foo xs
  | foo x = x
\end{sml}
      \\ \hline
    \end{tabular}
  \end{center}

\noindent
There is not much the normalisation changes here other than the order of the
clauses as \ttt{x :: xs} is more specific than \ttt{nil}

We have the following scheme instance of the \textsf{map} rule for the
normalised \ttt{foo} function

\begin{center}
  \begin{tabular}{c | Mr @{} Ml Mr @{} Ml Mr @{} Ml Mr @{} Ml}
    \textbf{Clause} 
    & \multicolumn{6}{c}{\textbf{Metapatterns}}
    & \multicolumn{2}{c}{\textbf{Transformers}} 
    \\ \hline
    \#1
    &\mathcal{C} \mathrel{} & \mapsto \diamond 
    & \ol{x} \mathrel{} & \mapsto \ttt{x} 
    & \ol{xs} \mathrel{} & \ttt{xs} 
    & \mathbb{D}\ \ol{a} \mathrel{} & = \ttt{$\kappa(\ol{a})$ + 1}
    \\
    % same clause
    & \ttt{self} \mathrel{} & \mapsto \ttt{foo}
    &&
    &&
    &&
    \\ \hline
    \#2
    & \mathcal{D} \mathrel{} & \mapsto \ttt{nil}
    &&
    && 
    &&
    \\
  \end{tabular}
\end{center}

\noindent
and thus it can be rewritten with the following

\begin{center}
  \begin{tabular}{Ml Ml}
    \mathcal{C}[\ol{xs}]  == \mathcal{C}[\ttt{xs}] == \kappa{(\ttt{xs})} == \ttt{xs}
    & \mathcal{C}[\ol{m}] == \kappa{(\ol{m})} == \ttt{a}^{(\dag)} 
    \\ \mathbb{D}\ \ttt{a} == \ttt{a + 1} & \\    
  \end{tabular} \\
  \small{$(\dag)$} for \ttt{a} being a free variable in the environment
\end{center}

\noindent
to

\begin{center}
  \begin{tabular}{|l|}
    \hline
    \textbf{Rewritten function} \\ \hline
  \begin{sml}
fun foo xs = map (fn a => a + 1) xs
  \end{sml} \\ \hline
\end{tabular}

\end{center}

\end{example}

\begin{example}{Advanced \textsf{map}-instance}
  eks 2009
  From the exam set of 2009, the students was asked to take the below
  function and then rewrite it using higher order functions. Since the recursion
  is inside the \ttt{if}-statement, it will not directly match the
  \textsf{map}-rule. To be able to match it we need to modify it slightly such
  that the recursion is outside the \ttt{if}-statement. 

  \paragraph{Note.} This modification could just as well have been done by
  rewriting rule. 

  \fixme{Maybe some reference to the simp set of rewriting rules and how they in
    general could help the original rewriting rules matching more code}

  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Original function} 
      & 
      % Empty cell
      \\ \hline
      \begin{sml}
fun collatz [] = []
  | collatz (x :: xs) = 
      if x mod 2 = 0 then 
        x div 2 :: collatz xs
      else 
        3*x + 1 :: collatz xs
      \end{sml}  
      & 
      % Empty cell
      \\ \hline
      % New row
      \textbf{Modified function} 
      &
      \textbf{Normalised function}
      \\ \hline
      \begin{sml}
fun collatz [] = []
  | collatz (x :: xs) = 
      (if x mod 2 = 0 then 
       x div 2 else 3*x + 1)
      :: collatz xs        
      \end{sml}
      &
      \begin{sml}
fun collatz (x :: xs) = 
    (if x mod 2 = 0 then
     x div 2 else 3 * x + 1) 
     :: collatz xs
  | collatz x = x        
      \end{sml}
    \end{tabular}
  \end{center}
  


\noindent


\end{example}

\begin{example}{Advanced \textsf{map}-instance with multiple arguments}
  One of the discarded assignments from 2008 was:

fun mapfil (f, p, []) = []
  | mapfil (f, p, (x::xs)) = (if p x then f x else x) :: mapfil(f, p, xs)



fun mapfil (f,p,xs) => map (fn a => if p a then f a else a) xs

\end{example}


\begin{example}
group assignment 4 2010
  \begin{sml}
fun evallist [] v      = []
  | evallist (f::fs) v = f v :: evallist fs v    
  \end{sml}
\end{example}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
