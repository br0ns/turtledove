\chapter{Introduction}

This project set out with the goals to create a system (Turtledove) for ``Tool
assisted programming in SML, with special emphasis on semi- automatic
rewriting'' in SML. To do this Turtledove is made of a few key components and a
plug-in system for tools. The key components include an parser for MLB and
SML files inspired by the work of \cite{mbp08}, a project manager for managing
the users source files and any changes done to them by the user outside
Turtledove or any changes made by Turtledove, a communication bridge to handle
all communication between Turtledove and the user's development environment.

Rewriting of programs are done trough a rewriting tool. This tool has its own
(rule) parser that extends on the SML parser, for reading in rules at run
time. Thus new rules can be added by the user without any changes to the
internals of Turtledove. Rules may be defined for both expressions and
(function) clauses:

\begin{description}
\item[Expressions] These rules mainly intend to function as a set of
  simplification rules but are not limited to this. 

  Such simplifications could be 

  \begin{center}    
  \begin{tabular}{ccc}
    "" \^{} s $->$ s
    & n + 0 $->$ n
    & 0 * n $->$ 0
    \\
    n * 1 $->$ 1
    &l @ [] $->$ l
    &\\
    true orelse b $->$ true
    &if b then true else false $->$ b
    &if b then true else t $->$ b orelse t    
  \end{tabular}
  \end{center}

\item[Clauses] These are more high level rewrites that intend to rewrite entire
  functions and are the main focus for this project. Examples of functions that
  can be rewritten are 

\begin{minipage}{1.0\linewidth}
  \begin{tabular}{lcl}
\begin{sml}
fun foo (x::xs) = x+1 :: foo xs
  | foo []      = []     
\end{sml}
  & $->$ &
\begin{sml}
fun foo xs = map op+ xs      
\end{sml}
  \end{tabular}
\end{minipage}
\end{description}

\noindent
and we define three rules for rewriting clauses to \ttt{map}, \ttt{foldl} and \ttt{foldr}.

Other tools include

\begin{description}
\item[Todo] Returns all SML comments that start with the string ``TODO'' in the
  current project to the development environment.

\item[Auto completion] Returns a list of visible names given a position in the
  source text (scope) to the development environment\footnote{The auto
    completion has been request on the MLton mailing list
    \url{http://mlton.org/pipermail/mlton/2005-July/027571.html} among other
    features that could be implemented as tools.}.
\end{description}


Unfortunately the goals were not fully met. The achievements of the project
are limited to

\begin{itemize}

\item A discussion of the implemented software as well as suggestions for
improvements and future work.
\item An MLB and SML parser. 
\item Environment and infix resolving on SML AST's.
\item A general purpose library with auxiliary functions and data structures.
\item A partial SML AST pretty printer (mainly missing signatures, structures
  and functors). 
\item Stand alone application that can normalise an SML AST
\item Stand alone application that implement a hard coded map rewriter
  \fixme{minor bugs with this one}

\item A few stand alone applications that implement various features of intended
  tools such as todo's and total project code size
\end{itemize}



\section{Problem Statement}

Refer to HARE and Stratego at the least.

{\footnotesize [Huge explanation about the actual problem.]}

An example is the similar but much more developed, and much larger project, The
Haskell Refactorer, HaRe\footnote{See \cite{HARE}.} that performs
transformations in Haskell. 


\section{Motivation}
\label{sec:motivation}
Suppose that we want to find code that could be written shorter using the
\texttt{map} function.
Here is an obvious example:
\begin{sml}
fun add (x :: xs) = x + 1 :: add xs
  | add nil       = nil
\end{sml}
can be rewritten to
\begin{sml}
val add = map (fn x => x + 1)
\end{sml}

But suppose that the first function was instead
\begin{sml}
fun add nil       = nil
  | add (x :: xs) = x + 1 :: add xs
\end{sml}
or even\footnote{We have seen novice SML programmers write functions similar to
  this.}
\begin{sml}
fun add (x :: xs) = x + 1 :: add xs
  | add [x]       = x + 1 :: add nil
  | add nil       = nil
\end{sml}
Of course all three examples can be rewritten to the same form. So should we
have three rewriting rules? Infinitely many? No.

Our problem here is that equivalent matches (a match is a list of pairs of
patterns and expressions) can take many forms.

In this paper we define a language similar to Core SML. We define a
normal form for matches. We then show how to obtain an equivalent normal form
from an arbitrary match.

\paragraph{Further work.}
The reader might find it odd that the second line in the last example above ends
in \smlinline{:: add nil}. Novice programmer or not, real code probably does not
look like this. The reason is that if \smlinline{:: add nil} is left out, the three
versions of the function \smlinline{add} does not have the same normal form.

We would like to determine that
\begin{sml}
fun add (x :: xs) = x + 1 :: add xs
  | add [x]       = [x + 1]
  | add nil       = nil
\end{sml}
is indeed equivalent to
\begin{sml}
fun add (x :: xs) = x + 1 :: add xs
  | add nil       = nil
\end{sml}
In the first function the patterns in line one and two is \smlinline{x :: xs}
and \smlinline{x :: nil}, so we can try to instantiate \smlinline{xs} to
\smlinline{nil} in the first function body, to try to eliminate the second line
of the function.

The first body becomes \smlinline{x + 1 :: add nil} which is not equal to the
second which is \smlinline{x + 1 :: nil}. But if we inline the definition of
\smlinline{add} in the first body we get \smlinline{x + 1 :: nil}. And so the
second line of the body can be eliminated.

Of course inlining function definitions to find a normal form, makes the
reduction to normal forms an undecidable problem.

For this reason we have decided to define a normal form that can always be
found, and then build on top of that.

Consider this other example:
\begin{sml}
fun add (x :: xs, b) = x + b :: add xs
  | add (nil, _)     = nil
\end{sml}
That too can be written using \smlinline{map}. But again we would need a new
rewriting rule for that. A solution could be to use meta patterns in rewriting
rules.

\fixme[inline,margin=false]{Ok, I'm just ranting here. Keeping the example for
  further brainstorm later on.}

\section{Readers prerequisites}

Readers of this text should, as a minimal prerequisite, be familiar with
Standard ML. Some knowledge of compiler design and programming language theory,
is also recommended. Also some algorithmic and mathematically maturity will be
of help. Any to-be computer scientist with a few years experience should be able
to either directly understand this text, or be able to easily acquire the needed
knowledge.\\

\noindent
Literature that may prove helpful:

\begin{itemize}
\item {The definition of Standard ML revised, \cite{SML97}.}.
\item {Commentary on Standard ML, \cite{SMLCOMM}.} Very helpful when reading
  \cite{SML97}.
\item {A Lexical Analyzer Generator for Standard ML, \cite{MLLEX}.} A
  description of, and a tutorial to, the software ML-Lex. It is not in print,
  but can be viewed online here:
  \url{http://www.smlnj.org/doc/ML-Lex/manual.html}
\item {ML-Yac Users Manual, \cite{MLYACC}.} A description of, and a tutorial to, the
  software ML-Yacc. It is not in print, but can be viewed online here:
  \url{http://www.smlnj.org/doc/ML-Yacc/index.html}.
\end{itemize}

\fixme{Why not reference the paper where lex and yacc are combined? It seems to
  be much newer and updated examples}

\section{Structure outline}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
