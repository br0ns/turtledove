\documentclass[a4paper,oneside]{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}


\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF


%% \renewcommand{\ttdefault}{pcr} % Bedre typewriter font
%% %\usepackage[sc]{mathpazo}     % Palatino font
%% \renewcommand{\rmdefault}{ugm} % Garamond
\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{-1} % Sæt overskriftsnummereringsdybde. Disable = -1.

\newcommand{\EDSL}{EDSL (Embedded Domain Specific Language) \renewcommand{\EDSL}{ EDSL }}
\hyphenation{da-ta-be-hand-ling}
\hyphenation{pro-gram-me-rings-sprog-et}
\hyphenation{brug-es}

\title{Synopsis}

\author{Johan Brinch (zerrez@gmail.com) \and
Morten Brøns-Pedersen (mortenbp@gmail.com) \and
Jesper Reenberg (jesper.reenberg@gmail.com)}




\date{\today}
\pagestyle{plain}



\begin{document}
\maketitle

\section{Project title}

``Skal vi lege Dr.?''

\section{Project overview}

Programs written in declarative programming languages has a wide veracity of
advantages that makes them specially suited for quick and correct statical
analysis.

\fixme{hvilke?}

The main purpose of this project is to develop one or more tools based on static analysis, and to
make these tools available to programmers - especially beginners - in a suiting manner. Preferably
through an IDE such as f.ex. Emacs. It is paramount for real world use that the tools work on whole
projects (described through .mlb or .cm files) and not just single SML files.\\

The list of tools one would like to have goes on. Therefore we focus on one in particular. Namely
semi automatic refactoring of function definition to standard forms. Given two finite sets $P$
(``patterns'') and $C$ (``code'') of function definitions the tool will return a series of
propositions for refactoring the code $C$. Such a proposition is a set, $F$, of declarations such that a
subset of $F$ has the same signature as $C$ but to more extend uses declarations that shares syntax tree
with declarations from $P$.

\fixme{bør andre typer plugins nævnes? Disse kan jo evt blot pilles væk i
  afgrænsningen}


%\begin{quotation}
%  Programmer i deklarative programmeringssprog har en række fordele, som gør dem
%  særdeles velegnet til hurtig og korrekt statisk analyse.
%
%  Formålet med denne opgave er at udnytte ovenstående til at foretage
%  halvautomatiske refaktoreringer, som kun vanskeligt kan benyttes (eller
%  sjældent er relevante) i øvrige sprog.
%\end{quotation}

\section{Elaboration}

\subsection{Motivation}

The target audience for this tool is novice programmers in functional
programming languages who is not used to work with the programming patterns
and -templates from this paradime. 

% \begin{quotation}
%   Målgruppen for det udviklede værktøj er novicer i funktionsprogrammering, som
%   ikke er vant til at benytte de særlige programmeringsmønstre og -skabeloner
%   fra dette paradigme.
% \end{quotation}



\subsection{Implementation}
We focus on creating a tool that will be easy to extend in the future. The tool consists of two
parts; a package for Emacs that is responsible for doing all communication with the programmer, and
a program that implement the actual tool(s). The communication will be done in JSON, for simplicity
and easy porting to other front ends.\\

The tool should consist of some major parts:
\begin{description}
\item[Project manager.] The tool be able to work on whole projects. The project manager is at the
least responsible for reading .mlb files. It can then be extended to actually manage projects. That
is supply means for adding and removing files and for writing project files back to disk.
\item[Parser.] Virtually every tool that does some analysis on source code need the source code to
be represented as a syntax tree. The parser creates syntax trees from source files. The least amount
of work to be done is to create concrete syntax trees that exactly describe the source text. Further
analysis can be done to for example obtain type information or remove derived forms (e.g., syntactic
sugar).
\item[The tools.] When the source text has been preprocessed the actual tools can work on it. The
tools can then make suggestions that will be sent to the user.
\end{description}

Apart from the above the parts need to be tied together and communication with the user taken care
of.





\subsubsection{Thoughts about implementation:}
\fixme{this needs to be merged into the synopsis.}
\begin{itemize}
\item Datastrukturer i flow ned igennem, skal bygge videre og ikke smide noget
  data væk.

\item Al kommunikation mellem frontend og server sker igennem JSON via IO.

\item Plugins skal kompiles med. (Alle plugins skal være slukket fra start)


\item Der kan tænkes flere forskellige SML parser niveauer 
  \begin{itemize}

  \item Der skal derfor indføres "runlevels". Så ved hvert parsnings afslut skal
    de plugin spawnes som "hooker" dette parsetræ (evt. kun 1 tråd der efter tur
    eksekverer alle plugins som hooker den givne level), samtidig med at der
    spawnes en tråd til at lave næste parsnings niveau.
  \end{itemize}
\end{itemize}

\section{Learning objectives}

\begin{enumerate}
\item 
\end{enumerate}

\section{Afgrænsninger}
\fixme{change title to english.}

\begin{enumerate}
\item There will not be developed a \textit{.CM}-file parser to the
  \texttt{Source Description} interface.

\item The \texttt{SML Parser} will not handle syntax errors. 
\end{enumerate}


\section{Task's}

\begin{enumerate}
\item Design the \texttt{Source Description} API. (1 week)

\item Implement a \textit{.MLB}-file parser (\texttt{MLB Parser}) from the MLB
  definition (1 week) 
\url{http://www.itu.dk/research/mlkit/index.php/ML_Basis_Files}

\item Design the concrete syntax tree to be used by the \texttt{SML
    Parser}. This needs to be done correct the first time. (1 week)

\item Create the \texttt{SML Parser} (3 weeks).

\item Create the \texttt{Refactoring Plugin} (3 weeks).

\item Create the \texttt{SMLserver} (1 week).
  \begin{itemize}
  \item Connect the \texttt{SML Parser} and \texttt{Refactoring Plugin} using threads
  \end{itemize}

\item Create the missing links in the \texttt{SMLserver} (2 weeks)
  \begin{itemize}
  \item Create the \texttt{non project files parser}\footnote{correct to the
      right name} and connect it with the \texttt{MLB Parser} into the
    \texttt{Source Description}.

  \item Create the \texttt{Project Manager}.

  \item Connect the \texttt{Source Description} with the \texttt{Project
      Manager}.

  \item Connect the \texttt{Project Manager} with the \texttt{SML Parser}.
  \end{itemize}

\item Create the \texttt{Communication Interface} between the \texttt{SMLserver}
  and the front end
  \begin{itemize}
  \item Create a plugin to the front end that will support the
    \texttt{Communication Interface}.
  \end{itemize}
\end{enumerate}

\section{Expansion (``nice to have'')}


\begin{enumerate}
\item A incremental \texttt{SML Parser}

\item That the \texttt{SML Parser} can handle syntax errors. I.e. by skipping
  the source code until next valid expression and then continue to parse. The
  skipped part could be reported to then front end and then handled approprietly
  (e.g., underlined).

\item Support of \texttt{DocString} by the \texttt{Communication Bridge} so when
  the front end hovers a function call it can show the \texttt{DocString}
  describing parameters and what the function does.
\end{enumerate}


\appendix

\chapter{Timetable}

\fixme{her kommer en tidstabel}

\chapter{Flow diagram}
\fixme{Make diagram bigger and still fit on page}
\includegraphics[width=0.9\textwidth]{../drawings/flow}



%\bibliographystyle{plain}
%\bibliography{synopsis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
