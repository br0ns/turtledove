\documentclass[oneside]{memoir}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

\usepackage[draft]{fixme}

\usepackage{mdwtab}
\usepackage{syntax}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\usepackage{fix-cm}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{fancyvrb}
\newenvironment{code}
{\quote\Verbatim}
{\endquote\endVerbatim}

\newcommand{\floor}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\codeinline}[1]{\texttt{#1}}

\chapterstyle{hangnum}

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}

\begin{document}

\listoffixmes{}

\chapter{Rewriting syntax}

\paragraph{Fixmes.} \ \\
\fixme[inline, margin=false]{Udvid normalform til at tage højde for datatyper. Specielt har vi brug
  for en funktion alá $dom$, som afgør et mønsters domæne.} \ \\

\fixme[inline, margin=false]{Indledning} \ \\

I SML kan et mønster opfatters som et træ hvor knuderne er konstruktører og
bladende er variable. Bemærk at nulære konstruktører ikke opfattes som blade.

I det nedenstående generaliserer vi mønstre til at være parametriserede over
deres blade. Således er et SML-mønster et mønster over (SML-)variable.

Vi følger konventionen at konstanter blot opfattes som nulære konstruktører.

Vi antager at alle \texttt{as}-mønstre er fjernet. Det kan let lade sig gøre ved
substitution.

\fixme[inline, margin=false]{noget med infix stuff...}

\input{definitions/definitions}

\input{semantics/semantics}

\input{intuition/intuition}

\input{examples/examples}

\input{rules/rules}

\appendix

\chapter{Sample rewriting rules}

\section{Map}


\fixme{The missing notation of meta variables makes the xs in the matching seem
  exactly the same.}
\begin{verbatim}
Rule Clauses Map
   | §C[x :: xs] => {D} §C[x] :: self §C[xs]
   | §D => nil
where
   dom §D = dom §C
becomes
   | §C[xs] => map (fn m => {D} §C[m]) xs
end
\end{verbatim}


\section{Fold}

\begin{verbatim}
Rule Clauses foldr
   | §C[x :: xs] => {D} (§C[x], self §C[xs])
   | §D => {E} §D
where
   dom §D = dom §C
becomes
   | §C[xs] => foldr (fn (a, b) => {D} (§C[a], b)) ({E} §C) xs
end
\end{verbatim}


\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
