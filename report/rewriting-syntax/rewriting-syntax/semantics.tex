
\section{Semantics}
A rewriting rule ``works'' on a list of SML-clauses. SML clauses are found in
function declarations, recursive value declarations, anonymous functions, case
expressions and exception handlers. A rewriting rule works on a sublist (not
necessarily proper) of such a list of clauses.

\paragraph{Remark.} In the scheme bodies we allow the keyword \textsf{self},
which we take to mean a recursive call.

\subsection{Inference rules}
\def\TheTrueColour{Maroon}
\newcommand{\becomesthrough}[3]{\ensuremath{#1}\textsf{\color{\TheTrueColour}\ becomes\ }\ensuremath{#2}\textsf{\color{\TheTrueColour}\ through\ }\ensuremath{#3}}

Along with the judgement form we give ``type specifications'' for each variable,
in the sense that any rule of the declared form has an implicit side condition
requireing values to belong to the stated set.

\fixme{Explain what $\sigma$ and $\theta$ are}

% \paragraph{Judgement} \fbox{$pat_1 \equiv_T pat_2$}\\

% See the MiniML paper for the definition of $\equiv_T$. It means that $pat_1$ and
% $pat_2$ are equal modulo variable names, and that $T$ is the (bijective) mapping
% from names in $pat_1$ to names in $pat_2$.

% \paragraph{Judgement} \fbox{$mpat_1 <- mpat_2 = mpat_3$}\\

% \fixme[inline,margin=false]{A more formal definition}

% Insert $mpat_2$ in the hole in $mpat_1$ with the lowest index. The result is
% $mpat_3$.

\paragraph{Judgement} \fbox{$\sigma(spat) = mpat$}\\

Substitute leafs of a scheme pattern according to the environment $\sigma$. Note
how holes are handled (rule 2 and 3).

\[
\inference
{
  \sigma(spat_1) = mpat_1 &
  \cdots &
  \sigma(spat_n) = mpat_n
}
{
  \sigma (con_1 (spat_1, \ldots, spat_n)) =
  con_2 (mpat_1, \ldots, mpat_n)
}
{
  con_1 = con_2
}
\]

\[
\inference
{
}
{
  \sigma (\mathcal{C}[mpat_1]\cdots[mpat_n]) =
  mpat[mpat_1/\diamond_1]\cdots[mpat_n/\diamond_n]
}
{
  \sigma(\mathcal{C}) = mpat
}
\]

\[
\inference
{
}
{
  \sigma(\diamond_i) = \diamond_i
}
\]

% \paragraph{Judgement} \fbox{$\theta(mpat) = pat$}\\

% Substitute all pattern variables by their image given by $\theta$, in the usual
% way. For completeness we present the rules below.

% Note that only hole free meta patterns are considered.

% \[
% \inference
% {
%   \theta(mpat_1) = pat_1 &
%   \cdots &
%   \theta(mpat_n) = pat_n
% }
% {
%   \theta (con_1 (mpat_1, \ldots, mpat_n)) =
%   con_2 (pat_1, \ldots, pat_n)
% }
% {
%   con_1 = con_2
% }
% \]

% \[
% \inference
% {
% }
% {
%   \theta(\overline{x}) = pat
% }
% {
%   \theta(\overline{x}) = pat
% }
% \]

\paragraph{Judgement} \fbox{$pat : \langle mpat, \theta \rangle$}\\

% The judgement $pat : \langle mpat, \theta \rangle$ means that the pattern is an
% instance of the pair of meta pattern $mpat$ and pattern variable environment
% $\theta$ in the environment $\sigma$.


\[
\inference
{
  pat_1 : \langle mpat_1, \theta_1 \rangle &
  \cdots &
  pat_n : \langle mpat_n, \theta_n \rangle &
}
{
  con (pat_1, \ldots, pat_n) :
  \langle con (mpat_1, \ldots, mpat_n), \theta_1 ++ \cdots ++
  \theta_n \rangle
}
\]

\[
\inference
{
}
{
  pat : \langle \overline{x}, \overline{x} \mapsto pat \rangle
}
\]

\paragraph{Judgement} \fbox{$\sigma, \theta |- sexp : exp$}\\

We have omitted the rules that deal with the structure of expressions and scheme
expressions.

Since the set of meta patterns is a subset of the set of scheme expressions
there exists a canonical mapping from meta patterns to scheme expressions. In
the following we call that mapping $\kappa$.

\fixme{Explain why we omitted them, why is it stupid?}

\[
\inference
{
}
{
  \sigma, \theta |- \textsf{self} : \texttt{(fn ($x_1$, $\ldots$, $x_n$) => $id$ $x_1$ $\cdots$ $x_n$)}
}
{
  (id, n) = \sigma(\textsf{self})
}
\]

\[
\inference
{
}
{
  \sigma, \theta |- \overline{x} : \texttt{x}
}
{
  \theta(\overline{x}) = \texttt{x}
}
\]

\[
\inference
{
  \sigma, \theta |- sexp[sexp_1/\diamond_1]\cdots[sexp_n/\diamond_n] : exp
}
{
  \sigma, \theta |- \mathcal{C}[sexp_1]\cdots[sexp_n] : exp
}
{
  sexp = \kappa(\sigma(\mathcal{C}))
}
\]

\[
\inference
{
  \sigma, \theta |- sexp_1 : exp_1 &
  \cdots &
  \sigma, \theta |- sexp_n : exp_n
}
{
  \sigma, \theta |- \mathbb{E}(sexp_1, \ldots, sexp_n) :
  \texttt{(fn $pat$ => $exp$)($exp_1$, $\ldots$, $exp_n$)}
}
{
  (pat, exp) = \sigma(\mathbb{E})
}
\]

\paragraph{Judgement} \fbox{$\sigma |- clause : sclause$}\\

% foobar

\[
\inference
{
  \sigma(spat) = mpat &
  \sigma |- pat : \langle mpat, \theta \rangle &
  \sigma, \theta |- sexp : exp
}
{
  \sigma |- pat \texttt{ => } exp : spat => sexp
}
\]

\paragraph{Judgement} \fbox{$\sigma |- clause^{+} : sclause^{+}$}\\

\[
\inference
{
  \sigma |- clause_1 : sclause_1 &
  \cdots &
  \sigma |- clause_n : sclause_n
}
{
  \begin{tabular}{Mc}
    clause_1\\
    \vdots\\
    clause_n\\
  \end{tabular}
  :
  \begin{tabular}{Mc}
    sclause_1\\
    \vdots\\
    sclause_n\\
  \end{tabular}
}
\]

\paragraph{Judgement} \fbox{$\sigma{\color{\TheTrueColour},}\ rule\ {\color{\TheTrueColour}|-}\ clause^{+}\ {\color{\TheTrueColour}\curvearrowright}\ clause^{+}$}\\

\fixme{Remember to take account of constrains in rules}
baz

\[
\inference
{
  \sigma |- clause^{+}_2 : sclause^{+}_1 &
  \sigma |- clause'^{+}_2 : sclause^{+}_2
}
{
  \sigma, sclause^{+}_1 \Downarrow sclause^{+}_2 |-
  \begin{tabular}{Ml}
    clause^{*}_1\\
    clause^{+}_2\\
    clause^{*}_3\\
  \end{tabular}
  \curvearrowright
  \begin{tabular}{Ml}
    clause^{*}_1\\
    clause'^{+}_2\\
    clause^{*}_3\\
  \end{tabular}
}
\]

\paragraph{Judgement} \fbox{\becomesthrough{exp_1}{exp_2}{rule}}\\

\[
\inference
{
  \sigma[\textsf{self} \mapsto (id, 1)], rule |-
  clause^{+} \curvearrowright clause'^{+}
}
{
  \becomesthrough
  {\texttt{val rec $id$ = fn $clause^{+}$}}
  {\texttt{val rec $id$ = fn $clause'^{+}$}}
  {rule}
}
\]

\[
\inference
{
  \sigma[\textsf{self} \mapsto (id, n)], rule |-
  clause^{+} \curvearrowright clause'^{+}
}
{
  \begin{array}{c}
    \begin{array}{l}
      \texttt{val rec $id$ = fn $pat_1$ => $\ldots$ fn $pat_n$ =>}\\
      \texttt{case ($pat_1$, $\ldots$, $pat_n$) of $clause^{+}$}
    \end{array}\\
    \textsf{\color{\TheTrueColour}\ becomes\ }\\
    \begin{array}{l}
      \texttt{val rec $id$ = fn $pat_1$ => $\ldots$ fn $pat_n$ =>}\\
      \texttt{case ($pat_1$, $\ldots$, $pat_n$) of $clause'^{+}$}
    \end{array}
  \end{array}
  \textsf{\color{\TheTrueColour}\ through\ }
  rule
}
\]

\[
\inference
{
  \sigma[\textsf{self} \mapsto \textsf{undef}], rule |-
  clause^{+} \curvearrowright clause'^{+}
}
{
  \becomesthrough
  {\texttt{case $exp$ of $clause^{+}$}}
  {\texttt{case $exp$ of $clause'^{+}$}}
  {rule}
}
\]

\[
\inference
{
  \sigma[\textsf{self} \mapsto \textsf{undef}], rule |-
  clause^{+} \curvearrowright clause'^{+}
}
{
  \becomesthrough
  {\texttt{handle $exp$ of $clause^{+}$}}
  {\texttt{handle $exp$ of $clause'^{+}$}}
  {rule}
}
\]

\subsection{Transformers}

\subsection{Rules}



\fixme{Find på bedre måde at opstille disse definitions... Evt ligesom det gamle
uden definition environments.}

\subsection{Scheme bodies}

The grammar of \synt{sexp} and \synt{spat} is given by


\fixme{Add short comment about what this is: SML without types, added with ...}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
 
  <atsexp> ::= <scon>                                            \hfill \cmt{special constant}
  \alt ["op"] <longvid>                                          \hfill \cmt{value identifier}
  \alt "{" <sexprow> "}"                                         \hfill \cmt{record}
  \alt "\#" <lab>                                                \hfill \cmt{record selector}
  \alt "()"                                                      \hfill \cmt{$0$-tuple}
  \alt "(" <sexp>$_1$, $\ldots$ , <sexp>$_n$ ")"                 \hfill \cmt{$n$-tuple, $n \geq 2$}
  \alt "[" <sexp>$_1$, $\ldots$, <sexp>$_n$ "]"                  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <sexp>$_1$; $\ldots$; <sexp>$_n$ ")"                  \hfill \cmt{sequence, $n \geq 2$}  
  \alt "let" <dec> "in" <sexp>$_1$ ; $\ldots$ ; <sexp>$_n$ "end" \hfill \cmt{local decl, $n \geq 1$}
  \alt "(" <sexp> ")"
  
  <sexprow> ::= <lab> "=" <sexp> ["," <sexprow> ]          \hfill \cmt{expression row}

  <appsexp> ::= <atsexp>
  \alt <appsexp> <atsexp>                                  \hfill \cmt{application exp}

  <infsexp> ::= <appsexp>
  \alt <infsexp>$_1$ <vid> <infsexp>$_2$                   \hfill \cmt{infix expression}
  
  <sexp> ::= <infsexp>
  \alt <sexp>$_1$ "andalso" <sexp>$_2$                     \hfill \cmt{conjunction}
  \alt <sexp>$_1$ "orelse"  <sexp>$_2$                     \hfill \cmt{disjunction}
  \alt <rule-self>                                         \hfill \cmt{rule self}
  \alt <transformer>                                       \hfill \cmt{rule transformer}
  \alt <meta-pattern-sexp>                                 \hfill \cmt{rule meta pattern}
  \alt "if" <sexp>$_1$ "then" <sexp>$_2$ "else" <sexp>$_3$ \hfill \cmt{conditional}
  \alt "case" <sexp> "of" <smatch>                         \hfill \cmt{case analysis}
  \alt "fn" <smatch>                                       \hfill \cmt{function}
  
  <smatch> ::= <smrule> [ "|" <smatch> ]
  
  <smrule> ::= <spat> "=>" <sexp>
\end{grammar}

  \caption{Grammar for scheme expressions. This is the normal sml expression
    grammar but without types, exceptions and \texttt{while}.  See \fref{tab:rule-grammar} for
    the definition of \synt{rule-self}, \synt{transformer} and \synt{meta-pattern-sex}.}
  \label{tab:scheme-expressions}
\end{nonfloatingtable}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
  <atspat> ::= $\_$                              \hfill \cmt{wildcard}
  \alt <scon>                                    \hfill \cmt{special constant}
  \alt ["op"] <longvid>                          \hfill \cmt{value identifier}
  \alt "{" <spatrow> "}"                         \hfill \cmt{record}
  \alt "()"                                      \hfill \cmt{$0$-tuple}
  \alt "(" <spat>$_1$, $\ldots$, <spat>$_n$ ")"  \hfill \cmt{$n$-tuple, $n \geq  2$}
  \alt "[" <spat>$_1$, $\ldots$, <spat>$_n$ "]"  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <spat> ")" 

  <spatrow> ::= "..."                      \hfill \cmt{wildcard}
  \alt <lab> "=" <spat> [, <spatrow>]      \hfill \cmt{pattern row}
  \alt <vid> [ "as" <spat> ] [, <spatrow>] \hfill \cmt{label as variable}

  <spat> ::= <atspat>                      \hfill \cmt{atomic}
  \alt ["op"] <longvid> <atspat>           \hfill \cmt{constructed value}
  \alt <meta-pattern-spat>                 \hfill \cmt{rule meta pattern}
  \alt <spat>$_1$ <vid> <spat>$_2$         \hfill \cmt{constructed value (infix)}
  \alt ["op"] <vid> "as" <pat>             \hfill \cmt{layered}
\end{grammar}
  
  \caption{Grammar for scheme patterns. See \fref{tab:rule-grammar} for
    the definition of \synt{meta-pattern-spat}.}
  \label{tab:scheme-patterns}
\end{nonfloatingtable}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../rewriting-syntax"
%%% End: 
