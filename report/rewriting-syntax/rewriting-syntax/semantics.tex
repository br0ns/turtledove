
\section{Semantics}
A rewriting rule ``works'' on a list of SML-clauses. SML clauses are found in
function declarations, recursive value declarations, anonymous functions, case
expressions and exception handlers. A rewriting rule works on a sublist (not
necessarily proper) of such a list of clauses.

\paragraph{Remark.} In the scheme bodies we allow the keyword \textsf{self},
which we take to mean a recursive call.

\subsection{Inference rules}
\def\TheTrueColour{NavyBlue}
\newcommand{\becomesthrough}[3]{\ensuremath{#1}\textsf{\color{\TheTrueColour}\ becomes\ }\ensuremath{#2}\textsf{\color{\TheTrueColour}\ through\ }\ensuremath{#3}}

Along with the judgement form we give ``type specifications'' for each variable,
in the sense that any rule of the declared form has an implicit side condition
requireing values to belong to the stated set.

\paragraph{Judgement} \fbox{\becomesthrough{A}{B}{C}}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B & exp\\
  C & rule
\end{tabular}
\fixme{Reinsert $M''$ into $M$.}

\[
\inference
{
  M' \subseteq M &
  \sigma[\textsf{self} \mapsto (f, 1)] |- M' : S &
  \sigma[\textsf{self} \mapsto (f, 1)] |- M'' : R
}
{
  \becomesthrough
  {\texttt{val rec $f$ = fn $M$}}
  {\texttt{val rec $f$ = fn $M''$}}
  {S \Downarrow R}
}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma[\textsf{self} \mapsto (f, n)] |- M' : S &
  \sigma[\textsf{self} \mapsto (f, n)] |- M'' : R
}
{
  \begin{array}{c}
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{case ($a_1$, $\ldots$, $a_n$) of $M$}
    \end{array}\\
    \textsf{becomes}\\
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{case ($a_1$, $\ldots$, $a_n$) of $M''$}
    \end{array}
  \end{array}
  \textsf{ through }
  S \Downarrow R
}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma |- M' : S &
  \sigma |- M'' : R
}
{
  \becomesthrough
  {\texttt{case $e$ of $M$}}
  {\texttt{case $e$ of $M''$}}
  {S \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma |- M' : S &
  \sigma |- M'' : R
}
{
  \becomesthrough
  {\texttt{handle $M$}}
  {\texttt{handle $M''$}}
  {S \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{\becomesthrough{exp_1}{exp_2}{rule}}\\

\fixme[inline, margin=false]{Reinsert $M''$ into $M$ : $M'' = match_2, M = match_0$.}

\[
\inference
{
  match_1 \subseteq match_0 &
  \sigma[\textsf{self} \mapsto (id, 1)] |- match_1 : scheme &
  \sigma[\textsf{self} \mapsto (id, 1)] |- match_2 : R
}
{
  \becomesthrough
  {\texttt{val rec $id$ = fn $match_0$}}
  {\texttt{val rec $id$ = fn $match_2$}}
  {scheme \Downarrow R}
}
\]

\[
\inference
{
  match_1 \subseteq match_0 &
  \sigma[\textsf{self} \mapsto (id, n)] |- match_1 : scheme &
  \sigma[\textsf{self} \mapsto (id, n)] |- match_2 : R
}
{
  \begin{array}{c}
    \begin{array}{l}
      \texttt{val rec $id$ = fn $pat_1$ => $\ldots$ fn $pat_n$ =>}\\
      \texttt{case ($pat_1$, $\ldots$, $pat_n$) of $match_0$}
    \end{array}\\
    \textsf{\color{\TheTrueColour}\ becomes\ }\\
    \begin{array}{l}
      \texttt{val rec $id$ = fn $pat_1$ => $\ldots$ fn $pat_n$ =>}\\
      \texttt{case ($pat_1$, $\ldots$, $pat_n$) of $match_2$}
    \end{array}
  \end{array}
  \textsf{\color{\TheTrueColour}\ through\ }
  scheme \Downarrow R
}
\]

\[
\inference
{
  match_1 \subseteq match_0 &
  \sigma |- match_1 : scheme &
  \sigma |- match_2 : R
}
{
  \becomesthrough
  {\texttt{case $exp$ of $match_0$}}
  {\texttt{case $exp$ of $match_2$}}
  {scheme \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

\[
\inference
{
  match_1 \subseteq match_0 &
  \sigma |- match_1 : scheme &
  \sigma |- match_2 : R
}
{
  \becomesthrough
  {\texttt{handle $match_0$}}
  {\texttt{handle $match_2$}}
  {scheme \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\paragraph{Judgement} \fbox{$A <- B = C$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B, C & mpat
\end{tabular}\\

Insert $B$ in the hole in $A$ with the lowest index. The result is $C$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$mpat_1 <- mpat_2 = mpat_3$}\\

\fixme[inline,margin=false]{A more formal definition}

Insert $mpat_2$ in the hole in $mpat_1$ with the lowest index. The result is
$mpat_3$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\sigma(S) = M$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  S & spat\\
  M & mpat
\end{tabular}\\

\[
\inference
{
  \sigma(S_0) = M_0 &
  \cdots &
  \sigma(S_n) = M_n
}
{
  \sigma (\mathfrak{a} (S_0, \ldots, S_n)) =
  \mathfrak{a} (M_0, \ldots, M_n)
}
\]

\[
\inference
{
  M'_0 <- M_1 = M'_1 &
  \cdots &
  M'_{n-1} <- M_n = M'_n
}
{
  \sigma (\mathcal{C}[M_1]\cdots[M_n]) = M'_n
}
{
  \sigma(\mathcal{C}) = M'_0
}
\]

\[
\inference
{
}
{
  \sigma(\diamond_i) = \diamond_i
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\sigma(spat) = mpat$}\\

Replace all scheme patterns with the meta patterns they are bound to by
$\sigma$. This is extended to also work on trees of scheme patterns.

\[
\inference
{
  \sigma(spat_0) = mpat_0 &
  \cdots &
  \sigma(spat_n) = mpat_n
}
{
  \sigma (con (spat_0, \ldots, spat_n)) =
  con (mpat_0, \ldots, mpat_n)
}
\]

\[
\inference
{
  mpat'_0 <- mpat_1 = mpat'_1 &
  \cdots &
  mpat'_{n-1} <- mpat_n = mpat'_n
}
{
  \sigma (\mathcal{C}[mpat_1]\cdots[mpat_n]) = mpat'_n
}
{
  \sigma(\mathcal{C}) = mpat'_0
}
\]

\[
\inference
{
}
{
  \sigma(\diamond_i) = \diamond_i
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\theta(M) = P$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  M & mpat\\
  P & pat
\end{tabular}\\

Replace all pattern variables by their image given by $\theta$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\theta(mpat) = pat$}\\

\fixme[inline, margin=false]{More formal argument}

Replace all pattern variables by their image given by $\theta$.

\[
\inference
{
}
{
  \theta(\diamond_i) = \diamond_i
}
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\paragraph{Judgement} \fbox{$\sigma, \theta |- S : E$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  S & sexp\\
  E & exp
\end{tabular}\\

We have omitted the rules that deal with the structure of expressions and scheme
expressions.

\[
\inference
{
  \theta(\overline{a}) = P & \kappa(P) = E
}
{
  \sigma, \theta |- \overline{a} : E
}
\]

\[
\inference
{
  \sigma(\mathcal{C}[M_0]\cdots[M_n]) = M & \theta(M) = P & \kappa(P) = E
}
{
  \sigma, \theta |- \mathcal{C}[M_0]\cdots[M_n] : E
}
\]

% \[
% \inference
% {
%   \sigma |- \theta(S) = E'_0 \\
%   \sigma |- \theta(S_0) = E_1 & \cdots & \sigma |- \theta(S_n) = E_{n+1} \\
%   E'_0 <- E_1 = E'_1 & \cdots & E'_n <- E_{n+1} = E'_{n+1}
% }
% {
%   \sigma |- \theta(\mathbb{E}[S_0]\cdots[S_n]) = E'_{n+1}
% }
% {
%   \sigma(\mathbb{E}) = S
% }
% \]

\[
\inference
{
  \sigma(S_0) = M_0 & \ldots & \sigma(S_n) = M_n &
  \theta(M) = P' & P' \equiv_T P &
}
{
  \sigma, \theta |- \mathbb{E}[S_0]\cdots[S_n] = E[x_1/T(x_1)]\ldots[x_m/T(x_m)]
}
{
  \begin{aligned}
    & \mathfrak{T}_n(M_0, \ldots, M_n) = M\\
    & \sigma(\mathbb{E}) = (P, E)\\
    & dom(T) = \{x_1, \ldots, x_m\}
  \end{aligned}
}
\]

% \[
% \inference
% {
% }
% {
%   \sigma |- \theta(\diamond_i) = \diamond_i
% }
% \]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\sigma, \theta |- sexp : exp$}\\

We have omitted the rules that deal with the structure of expressions and scheme
expressions.

\fixme{Explain why we omitted them, why is it stupid?}

\[
\inference
{
  \theta(sexp) = pat & \kappa(pat) = exp
}
{
  \sigma, \theta |- sexp : exp
}
\]

\[
\inference
{
  \sigma(\mathcal{C}[mpat_0]\cdots[mpat_n]) = mpat & \theta(mpat) = pat & \kappa(pat) = exp
}
{
  \sigma, \theta |- \mathcal{C}[mpat_0]\cdots[mpat_n] : exp
}
\]

% \[
% \inference
% {
%   \sigma |- \theta(S) = E'_0 \\
%   \sigma |- \theta(S_0) = E_1 & \cdots & \sigma |- \theta(S_n) = E_{n+1} \\
%   E'_0 <- E_1 = E'_1 & \cdots & E'_n <- E_{n+1} = E'_{n+1}
% }
% {
%   \sigma |- \theta(\mathbb{E}[S_0]\cdots[S_n]) = E'_{n+1}
% }
% {
%   \sigma(\mathbb{E}) = S
% }
% \]

\fixme[inline,margin=false]{\small Below inference rule doesn't follow the
  judgement of sexp : exp, but are sexp = exp?}
\[
\inference
{
  \sigma(S_0) = M_0 & \ldots & \sigma(S_n) = M_n &
  \theta(M) = P' & P' \equiv_T P &
}
{
  \sigma, \theta |- \mathbb{E}[S_0]\cdots[S_n] = E[x_1/T(x_1)]\ldots[x_m/T(x_m)]
}
{
  \begin{aligned}
    & \mathfrak{T}_n(M_0, \ldots, M_n) = M\\
    & \sigma(\mathbb{E}) = (P, E)\\
    & dom(T) = \{x_1, \ldots, x_m\}
  \end{aligned}
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$A : \langle B, \theta \rangle$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A & pat\\
  B & mpat
\end{tabular}

\[
\inference
{
  p_0 : \langle \alpha_0, \theta_0 \rangle &
  \cdots &
  p_n : \langle \alpha_n, \theta_n \rangle &
}
{
  \mathfrak{a} (p_0, \ldots, p_n) :
  \langle \mathfrak{b} (\alpha_0, \ldots, \alpha_n), \theta_0 ++ \cdots ++
  \theta_n \rangle
}
{
  \mathfrak{a} = \mathfrak{b}
}
\]

\[
\inference
{
}
{
  p : \langle \overline{a}, \overline{a} \mapsto p \rangle
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$pat : \langle mpat, \theta \rangle$}\\

\[
\inference
{
  pat_0 : \langle mpat_0, \theta_0 \rangle &
  \cdots &
  pat_n : \langle mpat_n, \theta_n \rangle &
}
{
  con (pat_0, \ldots, pat_n) :
  \langle con (mpat_0, \ldots, mpat_n), \theta_0 ++ \cdots ++
  \theta_n \rangle
}
\]

\[
\inference
{
}
{
  pat : \langle mpat, mpat \mapsto pat \rangle
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$A \equiv_T B$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B & pat
\end{tabular}\\

See the MiniML paper for the definition of $\equiv_T$. It means that $A$ and $B$
are equal modulo variable names, and that $T$ is the mapping from names in $A$
to names in $B$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$pat_1 \equiv_T pat_2$}\\

See the MiniML paper for the definition of $\equiv_T$. It means that $pat_1$ and $pat_2$
are equal modulo variable names, and that $T$ is the mapping from names in $pat_1$
to names in $pat_2$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\sigma |- A : B$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A & clause^{+}\\
  B & sclause^{+}
\end{tabular}\\

\[
\inference
{
  \sigma(sp) = M &
  \sigma |- p : \langle M, \theta \rangle &
  \sigma, \theta |- se : e &
  \sigma |- m : S
}
{
  \sigma |-
  \begin{tabular}{c}
    \texttt{| $p$ => $e$}\\
    $m$
  \end{tabular}
  :
  \begin{tabular}{c}
    $\mid sp => se$\\
    $S$
  \end{tabular}
}
\]

% \paragraph{Judgement} \fbox{$\sigma |- A \leadsto B$}\\
% \indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
%   A & sclause^{+}\\
%   B & clause^{+}
% \end{tabular}\\

% \[
% \inference
% {
%   \sigma(S) = M' &
%   \iota(M') = \langle p, \theta \rangle &
%   \sigma, \theta |- E : e &
%   \sigma |- M \leadsto m
% }
% {
%   \sigma |-
%   \begin{tabular}{c}
%     $\mid S => E$\\
%     $M$
%   \end{tabular}
%   \leadsto
%   \begin{tabular}{c}
%     \texttt{| $p$ => $e$}\\
%     $m$
%   \end{tabular}
% }
% \]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Judgement} \fbox{$\sigma |- clause^{+} : sclause^{+}$}\\

Matching of SML clauses to scheme clauses.

\[
\inference
{
  \sigma(spat) = mpat &
  \sigma |- pat : \langle mpat, \theta \rangle \\
  \sigma, \theta |- sexp : exp &
  \sigma |- clause^{+} : sclause^{+}
}
{
  \sigma |-
  \begin{tabular}{c}
    \texttt{| $pat$ => $exp$}\\
    $clause^{+}$
  \end{tabular}
  :
  \begin{tabular}{c}
    $\mid spat => sexp$\\
    $sclause^{+}$
  \end{tabular}
}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Transformers}

\subsection{Rules}



\fixme{Find på bedre måde at opstille disse definitions... Evt ligesom det gamle
uden definition environments.}

\subsection{Scheme bodies}

The grammar of \synt{sexp} and \synt{spat} is given by


\fixme{Add short comment about what this is: SML without types, added with ...}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
 
  <atsexp> ::= <scon>                                            \hfill \cmt{special constant}
  \alt ["op"] <longvid>                                          \hfill \cmt{value identifier}
  \alt "{" <sexprow> "}"                                         \hfill \cmt{record}
  \alt "\#" <lab>                                                \hfill \cmt{record selector}
  \alt "()"                                                      \hfill \cmt{$0$-tuple}
  \alt "(" <sexp>$_1$, $\ldots$ , <sexp>$_n$ ")"                 \hfill \cmt{$n$-tuple, $n \geq 2$}
  \alt "[" <sexp>$_1$, $\ldots$, <sexp>$_n$ "]"                  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <sexp>$_1$; $\ldots$; <sexp>$_n$ ")"                  \hfill \cmt{sequence, $n \geq 2$}  
  \alt "let" <dec> "in" <sexp>$_1$ ; $\ldots$ ; <sexp>$_n$ "end" \hfill \cmt{local decl, $n \geq 1$}
  \alt "(" <sexp> ")"
  
  <sexprow> ::= <lab> "=" <sexp> ["," <sexprow> ]          \hfill \cmt{expression row}

  <appsexp> ::= <atsexp>
  \alt <appsexp> <atsexp>                                  \hfill \cmt{application exp}

  <infsexp> ::= <appsexp>
  \alt <infsexp>$_1$ <vid> <infsexp>$_2$                   \hfill \cmt{infix expression}
  
  <sexp> ::= <infsexp>
  \alt <sexp>$_1$ "andalso" <sexp>$_2$                     \hfill \cmt{conjunction}
  \alt <sexp>$_1$ "orelse"  <sexp>$_2$                     \hfill \cmt{disjunction}
  \alt <rule-self>                                         \hfill \cmt{rule self}
  \alt <transformer>                                       \hfill \cmt{rule transformer}
  \alt <meta-pattern-sexp>                                 \hfill \cmt{rule meta pattern}
  \alt "if" <sexp>$_1$ "then" <sexp>$_2$ "else" <sexp>$_3$ \hfill \cmt{conditional}
  \alt "case" <sexp> "of" <smatch>                         \hfill \cmt{case analysis}
  \alt "fn" <smatch>                                       \hfill \cmt{function}
  
  <smatch> ::= <smrule> [ "|" <smatch> ]
  
  <smrule> ::= <spat> "=>" <sexp>
\end{grammar}

  \caption{Grammar for scheme expressions. This is the normal sml expression
    grammar but without types, exceptions and \texttt{while}.  See \fref{tab:rule-grammar} for
    the definition of \synt{rule-self}, \synt{transformer} and \synt{meta-pattern-sex}.}
  \label{tab:scheme-expressions}
\end{nonfloatingtable}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
  <atspat> ::= $\_$                              \hfill \cmt{wildcard}
  \alt <scon>                                    \hfill \cmt{special constant}
  \alt ["op"] <longvid>                          \hfill \cmt{value identifier}
  \alt "{" <spatrow> "}"                         \hfill \cmt{record}
  \alt "()"                                      \hfill \cmt{$0$-tuple}
  \alt "(" <spat>$_1$, $\ldots$, <spat>$_n$ ")"  \hfill \cmt{$n$-tuple, $n \geq  2$}
  \alt "[" <spat>$_1$, $\ldots$, <spat>$_n$ "]"  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <spat> ")" 

  <spatrow> ::= "..."                      \hfill \cmt{wildcard}
  \alt <lab> "=" <spat> [, <spatrow>]      \hfill \cmt{pattern row}
  \alt <vid> [ "as" <spat> ] [, <spatrow>] \hfill \cmt{label as variable}

  <spat> ::= <atspat>                      \hfill \cmt{atomic}
  \alt ["op"] <longvid> <atspat>           \hfill \cmt{constructed value}
  \alt <meta-pattern-spat>                 \hfill \cmt{rule meta pattern}
  \alt <spat>$_1$ <vid> <spat>$_2$         \hfill \cmt{constructed value (infix)}
  \alt ["op"] <vid> "as" <pat>             \hfill \cmt{layered}
\end{grammar}
  
  \caption{Grammar for scheme patterns. See \fref{tab:rule-grammar} for
    the definition of \synt{meta-pattern-spat}.}
  \label{tab:scheme-patterns}
\end{nonfloatingtable}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../rewriting-syntax"
%%% End: 
