
\section{Semantics}
A rewriting rule ``works'' on a list of SML-clauses. In SML clauses are found in
function declarations, recursive value declarations, anonymous functions, case
expressions and exception handlers. A rewriting rule works on a sublist (not
necessarily proper) of such a list of clauses.

\paragraph{Remark.} In the scheme bodies we allow the keyword \textsf{self},
which we take to mean a recursive call.

\subsection{Inference rules}
\newcommand{\becomesthrough}[3]{#1 \textsf{ becomes } #2 \textsf{ through } #3}

Along with the judgement form we give ``type specifications'' for each variable,
in the sense that any rule of the declared form has an implicit side condition
requireing values to belong to the stated set.

\paragraph{Judgement} \fbox{\becomesthrough{A}{B}{C}}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B & exp\\
  C & rule
\end{tabular}
\fixme{Reinsert $M''$ into $M$.}

\[
\inference
{
  M' \subseteq M &
  \sigma[\textsf{self} \mapsto (f, 1)] |- M' : S &
  \sigma[\textsf{self} \mapsto (f, 1)] |- M'' : R
}
{
  \becomesthrough
  {\texttt{val rec $f$ = fn $M$}}
  {\texttt{val rec $f$ = fn $M''$}}
  {S \Downarrow R}
}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma[\textsf{self} \mapsto (f, n)] |- M' : S &
  \sigma[\textsf{self} \mapsto (f, n)] |- M'' : R
}
{
  \begin{array}{c}
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{case ($a_1$, $\ldots$, $a_n$) of $M$}
    \end{array}\\
    \textsf{becomes}\\
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{case ($a_1$, $\ldots$, $a_n$) of $M''$}
    \end{array}
  \end{array}
  \textsf{ through }
  S \Downarrow R
}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma |- M' : S &
  \sigma |- M'' : R
}
{
  \becomesthrough
  {\texttt{case $e$ of $M$}}
  {\texttt{case $e$ of $M''$}}
  {S \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

\[
\inference
{
  M' \subseteq M &
  \sigma |- M' : S &
  \sigma |- M'' : R
}
{
  \becomesthrough
  {\texttt{handle $M$}}
  {\texttt{handle $M''$}}
  {S \Downarrow R}
}
{\sigma = \textsf{self} \mapsto \textsf{undef}, \sigma'}
\]

\paragraph{Judgement} \fbox{$A <- B = C$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B, C & mpat
\end{tabular}\\

Insert $B$ in the hole in $A$ with the lowest index. The result is $C$.

\paragraph{Judgement} \fbox{$\sigma(S) = M$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  S & spat\\
  M & mpat
\end{tabular}\\

\[
\inference
{
  \sigma(S_0) = M_0 &
  \cdots &
  \sigma(S_n) = M_n
}
{
  \sigma (\mathfrak{a} (S_0, \ldots, S_n)) =
  \mathfrak{a} (M_0, \ldots, M_n)
}
\]

\[
\inference
{
  M'_0 <- M_1 = M'_1 &
  \cdots &
  M'_{n-1} <- M_n = M'_n
}
{
  \sigma (\mathcal{C}[M_1]\cdots[M_n]) = M'_n
}
{
  \sigma(\mathcal{C}) = M'_0
}
\]

\[
\inference
{
}
{
  \sigma(\diamond_i) = \diamond_i
}
\]

\paragraph{Judgement} \fbox{$\theta(M) = P$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  M & mpat\\
  P & pat
\end{tabular}\\

Replace all pattern variables by their image given by $\theta$.


\paragraph{Judgement} \fbox{$\sigma, \theta |- S : E$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  S & sexp\\
  E & exp
\end{tabular}\\

We have omitted the rules that deal with the structure of expressions and scheme
expressions.

\[
\inference
{
  \theta(\overline{a}) = P & \kappa(P) = E
}
{
  \sigma, \theta |- \overline{a} : E
}
\]

\[
\inference
{
  \sigma(\mathcal{C}[M_0]\cdots[M_n]) = M & \theta(M) = P & \kappa(P) = E
}
{
  \sigma, \theta |- \mathcal{C}[M_0]\cdots[M_n] : E
}
\]

% \[
% \inference
% {
%   \sigma |- \theta(S) = E'_0 \\
%   \sigma |- \theta(S_0) = E_1 & \cdots & \sigma |- \theta(S_n) = E_{n+1} \\
%   E'_0 <- E_1 = E'_1 & \cdots & E'_n <- E_{n+1} = E'_{n+1}
% }
% {
%   \sigma |- \theta(\mathbb{E}[S_0]\cdots[S_n]) = E'_{n+1}
% }
% {
%   \sigma(\mathbb{E}) = S
% }
% \]

\[
\inference
{
  \sigma(S_0) = M_0 & \ldots & \sigma(S_n) = M_n &
  \theta(M) = P' & P' \equiv_T P &
}
{
  \sigma, \theta |- \mathbb{E}[S_0]\cdots[S_n] = E[x_1/T(x_1)]\ldots[x_m/T(x_m)]
}
{
  \begin{aligned}
    & \mathfrak{T}_n(M_0, \ldots, M_n) = M\\
    & \sigma(\mathbb{E}) = (P, E)\\
    & dom(T) = \{x_1, \ldots, x_m\}
  \end{aligned}
}
\]

% \[
% \inference
% {
% }
% {
%   \sigma |- \theta(\diamond_i) = \diamond_i
% }
% \]

\paragraph{Judgement} \fbox{$A : \langle B, \theta \rangle$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A & pat\\
  B & mpat
\end{tabular}

\[
\inference
{
  p_0 : \langle \alpha_0, \theta_0 \rangle &
  \cdots &
  p_n : \langle \alpha_n, \theta_n \rangle &
}
{
  \mathfrak{a} (p_0, \ldots, p_n) :
  \langle \mathfrak{b} (\alpha_0, \ldots, \alpha_n), \theta_0 ++ \cdots ++
  \theta_n \rangle
}
{
  \mathfrak{a} = \mathfrak{b}
}
\]

\[
\inference
{
}
{
  p : \langle \overline{a}, \overline{a} \mapsto p \rangle
}
\]

\paragraph{Judgement} \fbox{$A \equiv_T B$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A, B & pat
\end{tabular}\\

See the MiniML paper for the definition of $\equiv_T$. It means that $A$ and $B$
are equal modulo variable names, and that $T$ is the mapping from names in $A$
to names in $B$.

\paragraph{Judgement} \fbox{$\sigma |- A : B$}\\
\indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
  A & clause^{+}\\
  B & sclause^{+}
\end{tabular}\\

\[
\inference
{
  \sigma(sp) = M &
  \sigma |- p : \langle M, \theta \rangle &
  \sigma, \theta |- se : e &
  \sigma |- m : S
}
{
  \sigma |-
  \begin{tabular}{c}
    \texttt{| $p$ => $e$}\\
    $m$
  \end{tabular}
  :
  \begin{tabular}{c}
    $\mid sp => se$\\
    $S$
  \end{tabular}
}
\]

% \paragraph{Judgement} \fbox{$\sigma |- A \leadsto B$}\\
% \indent\begin{tabular}{Ml@{$\ \in\ $}Ml}
%   A & sclause^{+}\\
%   B & clause^{+}
% \end{tabular}\\

% \[
% \inference
% {
%   \sigma(S) = M' &
%   \iota(M') = \langle p, \theta \rangle &
%   \sigma, \theta |- E : e &
%   \sigma |- M \leadsto m
% }
% {
%   \sigma |-
%   \begin{tabular}{c}
%     $\mid S => E$\\
%     $M$
%   \end{tabular}
%   \leadsto
%   \begin{tabular}{c}
%     \texttt{| $p$ => $e$}\\
%     $m$
%   \end{tabular}
% }
% \]

\section{Here be junk}


Below we give the semantics for applying rewriting rules. The set $id$ is the
set of identifiers. Identifiers are used to index environments. The set $rid$ is
$(var \times \mathbb{N}) \cup \{\textsf{undefined}\}$. These are the relevant
judgements:
\begin{eqnarray*}[l@{\quad\quad\quad}l]
  \becomesthrough{\alpha}{\beta}{\gamma} &\alpha, \beta \in exp, \gamma
  \in rules\\
  \\
  \rho, \Lambda, \Gamma |- m : s & \Lambda \in id \rightharpoonup mpat, \Gamma \in id
  \rightharpoonup trans\\
  & m \in match, s \in smatch, \rho \in var rid\\
  \\
  \Lambda, T |- p : \langle \alpha, T' \rangle & \Lambda \in id \rightharpoonup
  mpat, T, T' \in id \rightharpoonup pat\\
  & p \in pat, \alpha \in spat\\
  \\
  \rho, \Lambda, \Gamma, T |- b : \beta & \Lambda \in id \rightharpoonup mpat,
  \Gamma \in id \rightharpoonup trans\\
  & T \in id \rightharpoonup pvar, b \in pat, \beta \in spat, \rho \in rid\\
  \\
  \mathbb{D}(p) = e & \mathbb{D} \in trans, p \in pat, e \in exp\\
  \\
  \mathcal{C}[\alpha] = \mathcal{D} & \mathcal{C} \in mpat_n, \alpha \in
  pat^{pvar}, \mathcal{D} \in mpat_{n - 1}\\
  &\text{for some $n \in
    \mathbb{N}$}\\
  \rho, \Lambda, \Gamma |- \beta \leadsto b & \Lambda \in id \rightharpoonup mpat,
  \Gamma \in id \rightharpoonup trans,\\
  & \beta \in sexp, b \in exp, \rho \in rid\\
  \\
\end{eqnarray*}

\[
\inference{
  (f, 1), \Lambda, \Gamma |- m' : \gamma &
  (f, 1), \Lambda, \Gamma |- \delta \leadsto b
}{\becomesthrough{\texttt{val
      rec $f$ = fn $m$}}{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
}}
\]
\[
\inference{
  (f, n), \Lambda, \Gamma |- m' : \gamma &
  (f, n), \Lambda, \Gamma |- \delta \leadsto b
}{\becomesthrough{
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{  case ($a_1$, $\ldots$, $a_n$) of $m$}
    \end{array}
  }{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
}}
\]
\[
\inference{
  \textsf{undefined}, \Lambda, \Gamma |- m' : \gamma &
  \textsf{undefined}, \Lambda, \Gamma |- \delta \leadsto b
}
{
  \becomesthrough{\texttt{case $m$ of}}{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
  }
}
\]

where in the above three rules if
\[
m =
\begin{array}{lll}
  p_1 &=>& e_1\\
  &\vdots&\\
  p_i &=>& e_i\\
  &\vdots&\\
  p_j &=>& e_j\\
  &\vdots&\\
  p_n &=>& e_n
\end{array}
\]
then
\[
m' =
\begin{array}{lll}
  p_i &=>& e_i\\
  &\vdots&\\
  p_j &=>& e_j\\
\end{array}
\]
for some $1 \leq i < j \leq n$.

\[
\inference
{
  \Lambda, [] |- p : \langle \alpha, T \rangle&
  \beta[x_1/T(x_1)]\cdots[x_n/T(x_n)]
}
{
  \mathbb{D}(p) = b
}
{
  \mathbb{D} = (\alpha, \beta), \text{dom } T = x_1, \ldots, x_n
}
\]

We use the judgement $\Lambda, \Gamma |- m : s$ to mean that the list of clauses $m$ is
an instance of the scheme $s$ in the meta pattern environment $\Lambda$ and the
transformer environment $\Gamma$.

\[
\inference{\Lambda, [] |- p : \langle \alpha, T \rangle &
  \rho, \Lambda, \Gamma, T |- b : \beta &
\rho, \Lambda, \Gamma |- m : s}
{\rho, \Lambda, \Gamma |- p => b, m : \alpha => \beta, s}
\]

The judgement $\Lambda, T |- p : \langle \alpha, T' \rangle$ means that the
pattern $p$ is an instance of the scheme pattern $\alpha$ in the meta pattern
environment $\Lambda$ and the pattern variable environment $T$ with the
resulting pattern variable environment $T'$.

\[
\inference{\Lambda, T |- p_0 : \langle \alpha_0, T_o \rangle &
\Lambda, T_0 |- p_1 : \langle \alpha_1, T_1 \rangle &
\cdots &
\Lambda, T_{i-1} |- p_i : \langle \alpha_i, T' \rangle
}
{\Lambda, T |- \mathfrak{a}(p_0, \ldots p_i) : \langle \mathfrak{b}(\alpha_0,
  \ldots, \alpha_i), T' \rangle}
{\mathfrak{a} = \mathfrak{b}}
\]

\[
\inference
{
  \Lambda, T |- p : \langle \mathcal{D}, T' \rangle&
  \mathcal{C}[\alpha] = \mathcal{D}
}
{
  \Lambda, T |- p : \langle \mathcal{C}[\alpha], T' \rangle
}
\]

\[
\inference
{
  \Lambda, T |- p : \langle \Lambda(\mathcal{C}), T' \rangle
}
{
  \Lambda, T |- p : \langle \mathcal{C}, T' \rangle
}
\]

\[
\inference{}
{\Lambda, T |- p : \langle \overline{a}, T[\overline{a} \mapsto p] \rangle}
\]

The judgement $\Lambda, \Gamma, T |- b : \beta$ means that the expression $b$ is
an instance of the scheme expression $\beta$. We have left out the rules that
handle the structure of expressions and scheme expressions.

\[
\inference{e = T(\overline{a})}
{\Lambda, \Gamma, T |- e : \overline{a}}
\]

\[
\inference{\Lambda, \Gamma, T |- e : \Lambda(\mathcal{C})}
{\Lambda, \Gamma, T |- e : \mathcal{C}}
\]

\[
\inference
{\Lambda, \Gamma, T |- e : \sigma(\mathcal{C}, \alpha)}
{\Lambda, \Gamma, T |- e : \mathcal{C}[\alpha]}
\]

\[
\inference{\Lambda, \Gamma, T |- e' : \beta}
{\Lambda, \Gamma, T |- e : \mathbb{E}(\beta)}{\Gamma(\mathbb{E})(e') = e}
\]

\subsection{Transformers}

\subsection{Rules}



\fixme{Find på bedre måde at opstille disse definitions... Evt ligesom det gamle
uden definition environments.}

\subsection{Scheme bodies}

The grammar of \synt{sexp} and \synt{spat} is given by


\fixme{Add short comment about what this is: SML without types, added with ...}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
 
  <atsexp> ::= <scon>                                            \hfill \cmt{special constant}
  \alt ["op"] <longvid>                                          \hfill \cmt{value identifier}
  \alt "{" <sexprow> "}"                                         \hfill \cmt{record}
  \alt "\#" <lab>                                                \hfill \cmt{record selector}
  \alt "()"                                                      \hfill \cmt{$0$-tuple}
  \alt "(" <sexp>$_1$, $\ldots$ , <sexp>$_n$ ")"                 \hfill \cmt{$n$-tuple, $n \geq 2$}
  \alt "[" <sexp>$_1$, $\ldots$, <sexp>$_n$ "]"                  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <sexp>$_1$; $\ldots$; <sexp>$_n$ ")"                  \hfill \cmt{sequence, $n \geq 2$}  
  \alt "let" <dec> "in" <sexp>$_1$ ; $\ldots$ ; <sexp>$_n$ "end" \hfill \cmt{local decl, $n \geq 1$}
  \alt "(" <sexp> ")"
  
  <sexprow> ::= <lab> "=" <sexp> ["," <sexprow> ]          \hfill \cmt{expression row}

  <appsexp> ::= <atsexp>
  \alt <appsexp> <atsexp>                                  \hfill \cmt{application exp}

  <infsexp> ::= <appsexp>
  \alt <infsexp>$_1$ <vid> <infsexp>$_2$                   \hfill \cmt{infix expression}
  
  <sexp> ::= <infsexp>
  \alt <sexp>$_1$ "andalso" <sexp>$_2$                     \hfill \cmt{conjunction}
  \alt <sexp>$_1$ "orelse"  <sexp>$_2$                     \hfill \cmt{disjunction}
  \alt <rule-self>                                         \hfill \cmt{rule self}
  \alt <transformer>                                       \hfill \cmt{rule transformer}
  \alt <meta-pattern-sexp>                                 \hfill \cmt{rule meta pattern}
  \alt "if" <sexp>$_1$ "then" <sexp>$_2$ "else" <sexp>$_3$ \hfill \cmt{conditional}
  \alt "case" <sexp> "of" <smatch>                         \hfill \cmt{case analysis}
  \alt "fn" <smatch>                                       \hfill \cmt{function}
  
  <smatch> ::= <smrule> [ "|" <smatch> ]
  
  <smrule> ::= <spat> "=>" <sexp>
\end{grammar}

  \caption{Grammar for scheme expressions. This is the normal sml expression
    grammar but without types, exceptions and \texttt{while}.  See \fref{tab:rule-grammar} for
    the definition of \synt{rule-self}, \synt{transformer} and \synt{meta-pattern-sex}.}
  \label{tab:scheme-expressions}
\end{nonfloatingtable}


\begin{nonfloatingtable}

\setlength{\grammarindent}{7em}

\newcommand{\cmt}[1]{\parbox{8em}{\small{#1}}}

\begin{grammar}
  <atspat> ::= $\_$                              \hfill \cmt{wildcard}
  \alt <scon>                                    \hfill \cmt{special constant}
  \alt ["op"] <longvid>                          \hfill \cmt{value identifier}
  \alt "{" <spatrow> "}"                         \hfill \cmt{record}
  \alt "()"                                      \hfill \cmt{$0$-tuple}
  \alt "(" <spat>$_1$, $\ldots$, <spat>$_n$ ")"  \hfill \cmt{$n$-tuple, $n \geq  2$}
  \alt "[" <spat>$_1$, $\ldots$, <spat>$_n$ "]"  \hfill \cmt{list, $n \geq 0$}
  \alt "(" <spat> ")" 

  <spatrow> ::= "..."                      \hfill \cmt{wildcard}
  \alt <lab> "=" <spat> [, <spatrow>]      \hfill \cmt{pattern row}
  \alt <vid> [ "as" <spat> ] [, <spatrow>] \hfill \cmt{label as variable}

  <spat> ::= <atspat>                      \hfill \cmt{atomic}
  \alt ["op"] <longvid> <atspat>           \hfill \cmt{constructed value}
  \alt <meta-pattern-spat>                 \hfill \cmt{rule meta pattern}
  \alt <spat>$_1$ <vid> <spat>$_2$         \hfill \cmt{constructed value (infix)}
  \alt ["op"] <vid> "as" <pat>             \hfill \cmt{layered}
\end{grammar}
  
  \caption{Grammar for scheme patterns. See \fref{tab:rule-grammar} for
    the definition of \synt{meta-pattern-spat}.}
  \label{tab:scheme-patterns}
\end{nonfloatingtable}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../rewriting-syntax"
%%% End: 
