\section{Semantics}
A rewriting rule ``works'' on a list of SML-clauses. In SML clauses are found in
function declarations, recursive value declarations, anonymous functions, case
expressions and exception handlers. A rewriting rule works on a sublist (not
necessarily proper) of such a list of clauses. In the following the regard a SML
clause as a set of a pattern and an expression (and thus we can use the $\alpha
=> \beta$ notation).

\paragraph{Remark.} In the scheme bodies we allow the keyword \textsf{self},
which we take to mean a recursive call.

\subsection{Meta patterns}

\subsection{Scheme bodies}

The grammar of $sexp$'s is given by
\setlength{\grammarindent}{7.3em}
\begin{grammar}
 
<atsexp>  ::= <scon>
          \alt "op" <longvid>
          \alt "{" <sexprow> "}"
          \alt "\#" <lab> 
          \alt "()"
          \alt "(" <sexp>, ..., <sexp> ")"
          \alt "let" <dec> "in" <sexp> "end"
          \alt "(" <sexp> ")"

<sexprow> ::= <lab> "=" <sexp> ["," <sexprow>] "\# fix correct meaning of this"

<sexp>    ::= <sexp> <atsexp>
          \alt <sexp> "andalso" <sexp>
          \alt <sexp> "orelse" <sexp>
          \alt <sexp> "handle" <smatch>
          \alt "if" <sexp> "then" <sexp> "else" <sexp>
          \alt "case" <sexp> "of" <smatch>
          \alt "fn" <smatch>

<smatch>  ::= <smrule> "<|" <smatch> ">" "\# fix wierd <|"

<smrule>  ::= <spat> "=>" <sexp>
\end{grammar}

\subsection{Rules}
\newcommand{\becomesthrough}[3]{#1 \textsf{ becomes } #2 \textsf{ through } #3}

Below we give the semantics for applying rewriting rules. The set $id$ is the
set of identifiers. Identifiers are used to index environments. The set $rid$ is
$(var \times \mathbb{N}) \cup \{\textsf{undefined}\}$. These are the relevant
judgements:
\begin{eqnarray*}[l@{\quad\quad\quad}l]
  \becomesthrough{\alpha}{\beta}{\gamma} &\alpha, \beta \in exp, \gamma
  \in rules\\
  \\
  \rho, \Lambda, \Gamma |- m : s & \Lambda \in id \rightharpoonup mpat, \Gamma \in id
  \rightharpoonup trans\\
  & m \in match, s \in smatch, \rho \in var rid\\
  \\
  \Lambda, T |- p : \langle \alpha, T' \rangle & \Lambda \in id \rightharpoonup
  mpat, T, T' \in id \rightharpoonup pat\\
  & p \in pat, \alpha \in spat\\
  \\
  \rho, \Lambda, \Gamma, T |- b : \beta & \Lambda \in id \rightharpoonup mpat,
  \Gamma \in id \rightharpoonup trans\\
  & T \in id \rightharpoonup pvar, b \in pat, \beta \in spat, \rho \in rid\\
  \\
  \mathbb{D}(\alpha) = \beta & \mathbb{D} \in trans, \alpha \in pat, \beta \in var\\
  \\
  \mathcal{C}[\alpha] = \mathcal{D} & \mathcal{C} \in mpat_n, \alpha \in
  pat^{pvar}, \mathcal{D} \in mpat_{n - 1}\\
  &\text{for some $n \in
    \mathbb{N}$}\\
  \rho, \Lambda, \Gamma |- \beta \leadsto b & \Lambda \in id \rightharpoonup mpat,
  \Gamma \in id \rightharpoonup trans,\\
  & \beta \in sexp, b \in exp, \rho \in rid\\
  \\
\end{eqnarray*}

\[
\inference{
  (f, 1), \Lambda, \Gamma |- m' : \gamma &
  (f, 1), \Lambda, \Gamma |- \delta \leadsto b
}{\becomesthrough{\texttt{val
      rec $f$ = fn $m$}}{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
}}
\]
\[
\inference{
  (f, n), \Lambda, \Gamma |- m' : \gamma &
  (f, n), \Lambda, \Gamma |- \delta \leadsto b
}{\becomesthrough{
    \begin{array}{l}
      \texttt{val rec $f$ = fn $a_1$ => $\ldots$ fn $a_n$ =>}\\
      \texttt{  case ($a_1$, $\ldots$, $a_n$) of $m$}
    \end{array}
  }{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
}}
\]
\[
\inference{
  \textsf{undefined}, \Lambda, \Gamma |- m' : \gamma &
  \textsf{undefined}, \Lambda, \Gamma |- \delta \leadsto b
}
{
  \becomesthrough{\texttt{case $m$ of}}{b}{
    \begin{array}{c}
      \gamma\\
      \Downarrow\\
      \delta
    \end{array}
  }
}
\]

where in the above three rules if
\[
m =
\begin{array}{lll}
  p_1 &=>& e_1\\
  &\vdots&\\
  p_i &=>& e_i\\
  &\vdots&\\
  p_j &=>& e_j\\
  &\vdots&\\
  p_n &=>& e_n
\end{array}
\]
then
\[
m' =
\begin{array}{lll}
  p_i &=>& e_i\\
  &\vdots&\\
  p_j &=>& e_j\\
\end{array}
\]
for some $1 \leq i < j \leq n$.

\subsection{Schemes}
We use the judgement $\Lambda, \Gamma |- m : s$ to mean that the list of clauses $m$ is
an instance of the scheme $s$ in the meta pattern environment $\Lambda$ and the
transformer environment $\Gamma$.

\[
\inference{\Lambda, [] |- p : \langle \alpha, T \rangle &
  \Lambda, \Gamma, T |- b : \beta &
\Lambda, \Gamma |- m : s}
{\Lambda, \Gamma |- p => b, m : \alpha => \beta, s}
\]

The judgement $\Lambda, T |- p : \langle \alpha, T' \rangle$ means that the
pattern $p$ is an instance of the scheme pattern $\alpha$ in the meta pattern
environment $\Lambda$ and the pattern variable environment $T$ with the
resulting pattern variable environment $T'$.

\[
\inference{\Lambda, T |- p_0 : \langle \alpha_0, T_o \rangle &
\Lambda, T_0 |- p_1 : \langle \alpha_1, T_1 \rangle &
\cdots &
\Lambda, T_{i-1} |- p_i : \langle \alpha_i, T' \rangle
}
{\Lambda, T |- \mathfrak{a}(p_0, \ldots p_i) : \langle \mathfrak{b}(\alpha_0,
  \ldots, \alpha_i), T' \rangle}
{\mathfrak{a} = \mathfrak{b}}
\]

\[
\inference
{\Lambda, \Gamma |- p : \Lambda(\mathcal{C})}
{\Lambda, \Gamma |- p : \mathcal{C}}
\]

\[
\inference
{\Lambda, \Gamma |- p : \sigma(\mathcal{C}, \alpha)}
{\Lambda, \Gamma |- p : \mathcal{C}[\alpha]}
\]

\[
\inference{}
{\Lambda, T |- p : \langle \overline{a}, T[\overline{a} \mapsto p] \rangle}
\]

The judgement $\Lambda, \Gamma, T |- b : \beta$ means that the expression $b$ is
an instance of the scheme expression $\beta$. We have left out the rules that
handle the structure of expressions and scheme expressions.

\[
\inference{e = T(\overline{a})}
{\Lambda, \Gamma, T |- e : \overline{a}}
\]

\[
\inference{\Lambda, \Gamma, T |- e : \Lambda(\mathcal{C})}
{\Lambda, \Gamma, T |- e : \mathcal{C}}
\]

\[
\inference
{\Lambda, \Gamma, T |- e : \sigma(\mathcal{C}, \alpha)}
{\Lambda, \Gamma, T |- e : \mathcal{C}[\alpha]}
\]

\[
\inference{\Lambda, \Gamma, T |- e' : \beta}
{\Lambda, \Gamma, T |- e : \mathbb{E}(\beta)}{\Gamma(\mathbb{E})(e') = e}
\]

\subsection{Transformers}

\subsection{Rules}




\fixme{Find på bedre måde at opstille disse definitions... Evt ligesom det gamle
uden definition environments.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../rewriting-syntax"
%%% End: 
