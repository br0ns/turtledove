% \documentclass[a4paper, oneside, final]{memoir} 
\documentclass[a4paper, oneside, draft]{memoir} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\britishhyphenmins}{22} 

% Fix of fancyref to work with memoir. Makes references look
% nice. Redefines memoir \fref and \Fref to \refer and \Refer.
% \usepackage{refer}             %
% As we dont really have any use for \fref and \Fref we just undefine what
% memoir defined them as, so fancyref can define what it wants.
\let\fref\undefined
\let\Fref\undefined
\usepackage{fancyref} % Better reference. 

\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{ulem} % \sout - strike-through
\usepackage{tikz}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function


\renewcommand{\ttdefault}{txtt} % Bedre typewriter font
% \usepackage[sc]{mathpazo}     % Palatino font
% \renewcommand{\rmdefault}{ugm} % Garamond
% \usepackage[garamond]{mathdesign}

% \overfullrule=5pt
% \setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\theoremstyle{definition}
\newtheorem{judgment}{Judgment}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}

\newcommand*{\fancyrefdeflabelprefix}{def}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefdefname}{Definition}
  \newcommand*{\frefdefname}{\MakeLowercase{\Frefdefname}}
}
\frefformat{vario}{\fancyrefdeflabelprefix}{%
  \frefdefname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefdeflabelprefix}{%
  \Frefdefname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyreflemlabelprefix}{lem}
\fancyrefaddcaptions{english}{
  \newcommand*{\Freflemname}{Lemma}
  \newcommand*{\freflemname}{\MakeLowercase{\Freflemname}}
}
\frefformat{vario}{\fancyreflemlabelprefix}{%
  \freflemname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyreflemlabelprefix}{%
  \Freflemname\fancyrefdeaultspacing#1#3%
}

\newcommand*{\fancyrefthmlabelprefix}{thm}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefthmname}{Theorem}
  \newcommand*{\frefthmname}{\MakeLowercase{\Frefthmname}}
}
\frefformat{vario}{\fancyrefthmlabelprefix}{%
  \frefthmname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefthmlabelprefix}{%
  \Frefthmname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyrefcorlabelprefix}{cor}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefcorname}{Corollary}
  \newcommand*{\frefcorname}{\MakeLowercase{\Frefcorname}}
}
\frefformat{vario}{\fancyrefcorlabelprefix}{%
  \frefcorname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefcorlabelprefix}{%
  \Frefcorname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyrefexlabelprefix}{ex}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefexname}{Example}
  \newcommand*{\frefexname}{\MakeLowercase{\Frefexname}}
}
\frefformat{vario}{\fancyrefexlabelprefix}{%
  \frefexname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefexlabelprefix}{%
  \Frefexname\fancyrefdefaultspacing#1#3%
}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\tnm}[1]{\textnormal{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}

\mathlig{||}{\parallel}
\mathlig{<'}{\prec}
\mathlig{>'}{\succ}
\mathlig{<='}{\preccurlyeq}
\mathlig{>='}{\succcurlyeq}
\mathlig{<=}{\leqslant}
\mathlig{>=}{\geqslant}
\mathlig{<>}{\neq}
\mathlig{|=}{\sqsubset}
\mathlig{=|}{\sqsupset}
\mathlig{==}{\equiv}
\mathlig{==a}{=_{\alpha}}
\mathlig{<|}{\lhd}
\mathlig{|>}{\rhd}
\mathlig{++}{+\!\!\!+}

\begin{document}
\chapter{Term rewriting in a subset of SML}

\section{Grammar}
\fixme{remember to introduce new relations with name.}
\begin{eqnarray*}[rqcql:Tl]
  var & = & (a-z)+ & Identifiers\\
  con & = & (A-Z)(a-z)* & Constructors\\
  num & = & \mathbb{Z}    & Natural numbers\\
  match & ::= & \epsilon                            & Empty match\\
  & & pat\texttt{.}exp\ \texttt{|}\ match               & Pattern -> expression\\
  pat & ::= & var                                       & Variable\\
  & & con\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} & Where con
  has arity $n$\\
  exp & ::= & var                                       & Variable\\
  & & exp_1 exp_2                                     & Application\\
  & & \lambda match                                  & Abstraction\\
  & & con\texttt{(}exp_1\texttt{,} \ldots\texttt{,} exp_n\texttt{)} & Where con
  has arity $n$\\
  dec & ::= & var \mapsto exp                         & Plain value binding\\
  & & \texttt{rec}\ var \mapsto \lambda match         & Recursive value binding\\
  & & con \texttt{:} \overline{num}                           & Constructor of arity $num$\\
  & & \epsilon                             & Empty program\\
  & & dec_1 \texttt{;} dec_2                                      & Sequencing
\end{eqnarray*} 

\paragraph{Note.} In the following we write $==a$ to mean alpha equivalence. We
also use (with superfixes, subfixes and primes) $v$, $c$, $n$, $m$, $p$, $e$ and
$d$ to range over $var$, $con$, $num$, $match$, $pat$, $exp$ and $dec$
respectively.

\section{Free variables, substitution and alpha equivalence}

\subsection{Structural equivalence of patterns}

We define two patterns to be structural equivalent with the following operator
$==_\sigma$ where $\sigma$ is a mapping of variables in one pattern to the
corresponding variables in another pattern.

An example could be $A(x,y) ==_\sigma A(z,x)$ where $\sigma$ becomes the mapping
$[x \mapsto z, y \mapsto x]$

\fixme{show that sigma is a bijection on variables}

\begin{definition}[Structural equivalence of patterns $==_\sigma$]
  \begin{eqnarray}[rlqTl]
    v_1 &==_{\sigma} v_2  & for $\sigma == [v_1 \mapsto v_2]$ \label{eq:struct-eq-var} \\
    c\ttt{(}p^1_1 \ttt{,} \ldots \ttt{,} p^1_n \ttt{)} & ==_{\sigma}
    c\ttt{(}p^2_1 \ttt{,} \ldots \ttt{,} p^2_n \ttt{)} & \label{eq:struct-eq-con}
  \end{eqnarray}

where \fref{eq:struct-eq-con} holds iff 

\begin{eqnarray*}[c]
  p^1_1 ==_{\sigma_1} p^2_1 \\
  \vdots \\
  p^1_n ==_{\sigma^n} p^2_n
\end{eqnarray*}
and $\sigma = \sigma_1 ++ \ldots ++ \ \sigma_n$
where $++$ is defined by 
\begin{eqnarray*}[rlqTl]
  (g ++ f)x &= f(x) & if $x \in \mrm{Dom}(f)$\\
  (g ++ f)x &= g(x) & otherwise
\end{eqnarray*}
note that the domains of each of the $\sigma$s are disjoint because no variable
can occur more than once in a pattern.
\end{definition}

Note that we write $==$ to denote $==_\sigma$ for a suitable $\sigma$ where
$\sigma$ has no interest.

\fixme{Show equivalence relation: reflexive, symmetric and transitive.}
\fixme{maybe show $p_1 ==_\sigma p_2$ iff $p_2 ==_{\sigma^{-1}} p_1$.}

\subsection{Free variables}

We define the free variables on expressions, matches and patterns with the tree
following functions $FV_{exp}$, $FV_{match}$ and $FV_{pat}$:


\begin{definition}[Free variables on expressions $FV_{exp}$] \ \\
  Inductively defined:
  \begin{eqnarray}[rl]
    FV_{exp} (v) &= \{v\} \\
    FV_{exp} (\lambda m) &= FV_{match} (m) \\
    FV_{exp} (e_1e_2) &= FV_{exp} (e_1) \cup FV_{exp} (e_2) \\
    FV_{exp} (con\ttt{(}e_1\ttt{,} \ldots \ttt{,} e_n \ttt{)}) &= FV_{exp}
    (e_1) \cup \ldots \cup FV_{exp} (e_n)
  \end{eqnarray}
\end{definition}

\begin{definition}[Free variables on matches $FV_{match}$]\ \\ 
  Inductively defined:
  \begin{eqnarray}[rl]
    FV_{match} (\epsilon) &= \emptyset \\
    FV_{match} (p\ttt{.}e\ \ttt{|}\ m) &= \left( FV_{exp}(e) \setminus
      FV_{pat}(p) \right) \cup FV_{match} (m)
  \end{eqnarray}
\end{definition}

\begin{definition}[Free variables on patterns $FV_{pat}$] \ \\
  Inductively defined:
  \begin{eqnarray}[rl]
    FV_{pat} (v) &= \{v\} \\
    FV_{pat} (con\ttt{(}p_1\ttt{,} \ldots \ttt{,} p_n\ttt{)}) &= FV_{pat} (p_1)
    \cup \ldots \cup FV_{pat} (p_n)
  \end{eqnarray}
\end{definition}

\subsection{Substitution}



\subsection{Alpha equivalence}

We denote alpha equivalence with the symbol $==a$ and use the same symbol for
both expressions, matches and patterns. 

\begin{definition}[Alpha equivalence on expressions $==a$]
  \begin{eqnarray}[rl]
    v_1 &==a v_2 \\
  \end{eqnarray}
\end{definition}

Two terms are alpha equivalent if and only if they can be proven to be so using
the above rules.

\section{Semantic equivalence}
We write $e_1 \sim e_2$ if $e_1$ and $e_2$ are semantically equivalent. That is
if $e_2$ is substituted for $e_1$ (or vice versa) in any program $d$ to obtain
$d'$, then if $d$ evaluates to something in an environment $\sigma$ then $d'$
evaluates to that something in $\sigma$.

\section{Orderings on patterns}
We define a total ($<=$) and a partial ($<='$) relation on patterns. Then we show
that they indeed are orderings.

We write $<$ and $<'$ for $<=$ and $<='$ strict (or irreflexive) counterparts
respectively.

As it turns out it is easier to define $<$ and $<='$ directly and then define
$<=$ and $<'$ in turn of those.

\begin{definition}[Strict total ordering $<$]\label{def:pat-total-order-strict}
  Assume a total strict ordering $\lessdot$ on constructors and
  variables\footnote{For example let all constructors come before all variables
    and let variables and constructors be ordered lexicographically among
    themselves. Note that constructors and variables are not compared in the
    definition of $<$.}. We inductively define:
  \begin{eqnarray}
    v_1 &<& v_2\label{eq:pat-total-order-strict-var}\\
    c\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<& v\\
    c_1\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<&
    c_2\texttt{(}p'_1\texttt{,} \ldots\texttt{,} p'_m\texttt{)}\label{eq:pat-total-order-strict-con}
  \end{eqnarray}
  Where \fref{eq:pat-total-order-strict-var} holds if
  \[
  v_1 \lessdot v_2
  \]
  and \fref{eq:pat-total-order-strict-con} holds if
  \[
  c_1 \lessdot c_2 \lor (c_1 = c_2 \land ( p_1 < p'_1 \lor p_1 = p'_1 \land (\ldots p_n < p'_n \ldots )))
  \]
\end{definition}

\begin{definition}[Total ordering $<=$]\label{def:pat-total-order-weak}
  We define the reflexive cousin:
  \begin{eqnarray*}
    p_1 <= p_2 \Longleftrightarrow p_1 < p_2 \lor p_1 = p_2
  \end{eqnarray*}
\end{definition}

\begin{definition}[Partial ordering $<='$]\label{def:pat-partial-order-weak}
  We say that $p_2$ weakly generalises $p_1$ or $p_1$ is at least as specific as
  $p_2$ and we write $p_1 <=' p_2$. Inductively defined.
  \begin{eqnarray}
    p &<='& v \label{eq:pat-partial-order-weak-var}\\
    c_1\texttt{(}p_1\texttt{,} \ldots\texttt{,} p_n\texttt{)} &<='&
    c_2\texttt{(}p'_1\texttt{,} \ldots\texttt{,} p'_m\texttt{)}\label{eq:pat-partial-order-weak-con}
  \end{eqnarray}
  Where \fref{eq:pat-partial-order-weak-con} holds if
  \begin{eqnarray*}
    c_1 &=& c_2 \quad \land\\
    p_1 &<='& p'_1 \quad \land\\
    &\ldots&\\
    p_n &<='& p'_n
  \end{eqnarray*}
\end{definition}

\begin{definition}[Strict partial ordering $<'$]\label{def:pat-total-order-strict}
  We define the strict counterpart of $<='$ by
  \begin{eqnarray*}
      p_1 <' p_2 \Longleftrightarrow p_1 <=' p_2 \land p_1 \not ==a p_2
  \end{eqnarray*}
\end{definition}

\begin{lemma}[Total ordering]\label{lem:pat-total-orderings}
  The relation $<=$ is a total ordering, and $<$ is a strict total ordering on
  patterns.
\end{lemma}

\begin{proof}
  We show that $<$ is irreflexive, transitive and total. Then it follows
  immediately by \fref{def:pat-total-order-weak} that $<=$ is a total ordering.
  \begin{description}
  \item[Irreflexivity.] Proof by contradiction. So assume $p < p$.
    \begin{description}
    \item[Case $p = v$.] We get the contradiction immediately by irreflexivity
      of $\lessdot$.
    \item[Case $p = c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)}$.] By
      the irreflexivity of $\lessdot$ it must be the case that
      \begin{eqnarray*}
        p_1 < p_1 \land \ldots \land p_n < p_n
      \end{eqnarray*}
      which by induction can not be the case, and we again have a contradiction.
    \end{description}

  \item[Transitivity.]
    Assume $p_1 < p_2 \land p_2 < p_3$. We show $p_1 < p_3$.

    If $p_3 = v$ then the result follows immediately. Therefore assume $p_3 = c_3
    \texttt{(}p^3_1 \texttt{,} \ldots \texttt{,} p^3_n\texttt{)}$.
    By the assumptions we have that $p_1 = c_1 \texttt{(}p^1_1 \texttt{,} \ldots
    \texttt{,} p^1_n\texttt{)}$, $p_2 = c_2 \texttt{(}p^2_1 \texttt{,} \ldots
    \texttt{,} p^2_n\texttt{)}$ and
    \begin{eqnarray}[c]
      c_1 < c_2 \lor c_1 = c_2 \land ( p^1_1 < p^2_1 \lor p^1_1 = p^2_1 \land
      (\ldots p^1_n < p^2_n \ldots )) \label{eq:trans-tot-proof-1}\\
      c_2 < c_3 \lor c_2 = c_3 \land ( p^2_1 < p^3_1 \lor p^2_1 = p^3_1 \land
      (\ldots p^2_n < p^3_n \ldots )) \label{eq:trans-tot-proof-2}
    \end{eqnarray}
    Combining \fref{eq:trans-tot-proof-1} and \fref{eq:trans-tot-proof-2} we get
    \begin{eqnarray*}[c]
      c_1 < c_2 \lor c_1 = c_2 \land c_2 < c_3 \lor c_2 = c_3 \land\\ ( p^1_1 < p^2_1
      \lor p^1_1 = p^2_1 \land p^2_1 < p^3_1 \lor p^2_1 = p^3_1 \land
      (\ldots p^1_n < p^2_n \land p^2_n < p^3_n \ldots ))
    \end{eqnarray*}
    And then using induction we get
    \begin{eqnarray*}
      c_1 < c_3 \lor c_1 = c_3 \land ( p^1_1 < p^3_1 \lor p^1_1 = p^3_1 \land
      (\ldots p^1_n < p^3_n \ldots ))
    \end{eqnarray*}
    and then by definition $p_1 < p_3$.

  \item[Totality.]
    Consider patterns $p_1 \neq p_2$. If either one is a variable we have $p_1
    < p_2$ or $p_2 < p_1$ directly by \fref{eq:pat-total-order-strict-con} or by
    the totality of $\lessdot$ and \fref{eq:pat-total-order-strict-var}.

    So assume $p_1 = c_1\texttt{(}p^1_1\texttt{,}\ldots\texttt{,}p^1_n\texttt{)}$
    and $p_2 = c_2\texttt{(}p^2_1\texttt{,}\ldots\texttt{,}p^2_n\texttt{)}$.

    If $c_1 \neq c_2$ we get $p_1 < p_2$ or $p_2 < p_1$ by the totality of
    $\lessdot$ and \fref{eq:pat-total-order-strict-con}.

    So assume $c_1 = c_2$. By induction we have $p^1_i < p^2_i \lor p^2_i <
    p^1_i \lor p^1_i = p^2_i$ for $i \in \{1, \ldots, n\}$. But it must be the
    case that $p^1_i \neq p^2_i$ for some $i$ for else $p_1 = p_2$ and then we
    have a contradiction. This implies that $p_1 < p_2$ (if $p^1_i < p^2_i$) or
    $p_2 < p_1$ (if $p^2_i < p^1_i$).

  \end{description}
\end{proof}

\begin{lemma}[Partial ordering]\label{lem:pat-partial-orderings}
  The relation $<='$ is a partial ordering and $<'$ is a strict partial ordering
  on patterns.
\end{lemma}

\begin{proof}
  We show that $<='$ is reflexive, antisymmetric and transitive. Then we show
  that $<'$ is irreflexive and transitive.
  \begin{description}
  \item[Reflexivity.]
    We want to show $p <=' p$.

    If $p = v$ then it follows by \fref{eq:pat-partial-order-weak-var}.

    So assume $p = c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)}$. It
    follows by induction that $p_1 <=' p_1 \land \ldots \land p_n <=' p_n$ and
    then by \fref{eq:pat-partial-order-weak-con} that $p <=' p$.

  \item[Antisymmetry.]
    

  \end{description}
\end{proof}

%%%%%%%%%%%%%


\begin{lemma}[Transitivity of $<$]
  \[
  p_1 < p_2 \land p_2 < p_3 \Rightarrow p_1 < p_3
  \]
\end{lemma}
\begin{proof}
  If $p_3 = v$ then the result follows immediately. Therefore assume $p_3 = c_3
  \texttt{(}p^3_1 \texttt{,} \ldots \texttt{,} p^3_n\texttt{)}$.
  By the assumptions we have that $p_1 = c_1 \texttt{(}p^1_1 \texttt{,} \ldots
  \texttt{,} p^1_n\texttt{)}$, $p_2 = c_2 \texttt{(}p^2_1 \texttt{,} \ldots
  \texttt{,} p^2_n\texttt{)}$ and
  \begin{eqnarray}[c]
    c_1 < c_2 \lor c_1 = c_2 \land ( p^1_1 < p^2_1 \lor p^1_1 = p^2_1 \land
    (\ldots p^1_n < p^2_n \ldots )) \label{eq:trans-tot-proof-1}\\
    c_2 < c_3 \lor c_2 = c_3 \land ( p^2_1 < p^3_1 \lor p^2_1 = p^3_1 \land
    (\ldots p^2_n < p^3_n \ldots )) \label{eq:trans-tot-proof-2}
  \end{eqnarray}
  Combining \fref{eq:trans-tot-proof-1} and \fref{eq:trans-tot-proof-2} we get
  \begin{eqnarray*}[c]
    c_1 < c_2 \lor c_1 = c_2 \land c_2 < c_3 \lor c_2 = c_3 \land\\ ( p^1_1 < p^2_1
    \lor p^1_1 = p^2_1 \land p^2_1 < p^3_1 \lor p^2_1 = p^3_1 \land
    (\ldots p^1_n < p^2_n \land p^2_n < p^3_n \ldots ))
  \end{eqnarray*}
  And then using induction we get
  \begin{eqnarray*}
    c_1 < c_3 \lor c_1 = c_3 \land ( p^1_1 < p^3_1 \lor p^1_1 = p^3_1 \land
    (\ldots p^1_n < p^3_n \ldots ))
  \end{eqnarray*}
  and then by definition $p_1 < p_3$.
\end{proof}

\begin{definition}[$p_1 <=' p_2$]
\end{definition}

\begin{definition}[$p_1 \prec p_2$]
  \[
  p_1 <' p_2 \Leftrightarrow p_1 <=' p_2 \land p_1 \not ==a p_2
  \]
\end{definition}

And we write $p_1 >=' p_2$ and $p_1 >' p_2$ to mean $p_2 <=' p_1$ and $p_2 <'
p_1$ respectively.

\begin{lemma}[Transitivity of $<'$ and $<='$]
  \begin{eqnarray*}
    p_1 <=' p_2 \land p_2 <=' p_3 \Rightarrow p_1 <=' p_3\\
    p_1 <' p_2 \land p_2 <' p_3 \Rightarrow p_1 <' p_3
  \end{eqnarray*}
  Since $<='$ is the reflexive extension of $<'$, then if $<='$ is transitive
  clearly so is $<'$. We prove the transitivity of $<='$.
  \begin{proof}
    If $p_3 = v$ the result follows immediately. So assume $p_3 = c_3
    \texttt{(}p^3_1 \texttt{,} \ldots \texttt{,} p^3_n\texttt{)}$.
    By the assumptions we have that $p_1 = c_1 \texttt{(}p^1_1 \texttt{,} \ldots
    \texttt{,} p^1_n\texttt{)}$, $p_2 = c_2 \texttt{(}p^2_1 \texttt{,} \ldots
    \texttt{,} p^2_n\texttt{)}$ and
    \begin{eqnarray}[c]
      c_1 = c_2 \land p^1_1 <=' p^2_1 \ldots p^1_n <=' p^2_n \label{eq:trans-part-proof-1}\\
      c_2 = c_3 \land p^2_1 <=' p^3_1 \ldots p^2_n <=' p^3_n \label{eq:trans-part-proof-2}
    \end{eqnarray}
    Combining \fref{eq:trans-part-proof-1} and \fref{eq:trans-part-proof-2} gives us
    \begin{eqnarray*}
      c_1 = c_2 \land c_2 = c_3 \land p^1 <=' p^2_1 \land p^2_1 <=' p^3_1 \ldots
      p^1_n <=' p^2_n \land p^2_n <=' p^3_n
    \end{eqnarray*}
    And then by induction we get
    \begin{eqnarray*}
      c_1 = c_3 \land p^1_1 <=' p^3_1 \ldots p^1_n <=' p^3_n
    \end{eqnarray*}
    which by definition gives us $p_1 <=' p_3$.
  \end{proof}
\end{lemma}

\begin{definition}[$p_1 || p_2$]
  \[
  p_1 || p_2 \Leftrightarrow p_1 \not <=' p_2 \land p_2 \not <=' p_1
  \]
\end{definition}

\begin{corollary}[Reflexivity of $||$]
  \[
  p_1 || p_2 \Leftrightarrow p_2 || p_1
  \]
\end{corollary}
\begin{proof}
  By definition.
\end{proof}


\begin{lemma}[Equivalence classes of patterns]
  \[
  \forall p_1, p_2 : p_1 ==a p_2 \lor p_1 <' p_2 \lor p_1 >' p_2 \lor p_1 || p_2
  \]
\end{lemma}
\begin{proof}
  Immediately by inspection.
\end{proof}

\begin{lemma}\label{tot-imp-part}
  \[
  p_1 < p_2 \Rightarrow p_1 <' p_2
  \]
\end{lemma}
\begin{proof}
  Immediately by induction.
\end{proof}

\section{Cover}

\begin{definition}
  Let $P = \{p_1, \ldots, p_n \}$, and $C = \{c_1, \ldots, c_n\}$ be the constructors
  defined in the current environment. Then
  \[
  \textnormal{Cov}P
  \]
if
\[
  x \in \{p_1, \ldots, p_n \} \lor (\forall c \in C : \textnormal{Cov} P_1 \land
  \ldots \textnormal{Cov} P_m)
\]
where
\begin{eqnarray*}
P_1 &=& \{p'_1 | p \in P \land p = c \texttt{(}p'_1\texttt{,}\ldots\texttt{,}p'_m\texttt{)}\}\\
&\vdots&\\
P_m &=& \{p'_m | p \in P \land p = c \texttt{(}p'_1\texttt{,}\ldots\texttt{,}p'_m\texttt{)}\}
\end{eqnarray*}
\end{definition}

\section{Elimination of unused patterns}\label{sec:elim-unus-patt}
\begin{definition}[$m_1 =| m_2$]
  Let
  \[
  m = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|} p_n\texttt{.}e_n
  \]
  If $p_j <=' p_i$ where $j > i$ then 
  \[
  m =| m'
  \]
  where
  \[
  m' = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|}
  p_{j-1}\texttt{.}e_{j-1} \texttt{|} p_{j+1}\texttt{.}e_{j+1} \texttt{|}
  \ldots \texttt{|} p_n\texttt{.}e_n
  \]
  In other words; pattern $j$ and its body can be removed from $m$.
\end{definition}

\begin{lemma}(Preservation)
  \[
  m \sqsupset m' \Rightarrow \forall e : \texttt{(}\lambda m\texttt{)}e \downarrow
  v \Leftrightarrow \texttt{(}\lambda m'\texttt{)}e \downarrow v
  \]
\end{lemma}
\begin{proof}
  Trivial (as if).
\end{proof}

\section{Partially ordered form}
\begin{definition}
  A match $m = p_1\texttt{.}e_1\texttt{|}\ldots\texttt{|}p_n\texttt{.}e_n$ is in
  partially ordered form iff
  \[
  \forall i \in \{1, \ldots, n\} : p_j \not <=' p_i \quad \textnormal{where $j > i$}
  \]

  Note that every match $m$ can be transformed to an equivalent match $m'$ such
  that $m'$ is in partially ordered form, by repeated elimination of unused
  patterns (\fref{sec:elim-unus-patt}).
\end{definition}

\section{Generalisation of patterns}

In the following we define generalisation of matches using the operator $<|$ using the
auxiliary operator $<|'$, which generalises patterns.


\begin{definition}[Generalisation of patterns $<|'$]\ \\
The syntactic category $pat$ is a proper subset of $exp$. Let $\kappa : pat
\rightarrow exp$ be the canonical mapping from $pat$ to $exp$.
\begin{eqnarray}[c]
  (c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)} , e)
  <|'
  (x , e[x/\kappa
  (c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)})]) \label{eq:gen-1}\\
  \begin{eqnalign}
    (c\texttt{(}p_1\texttt{,}\ldots\texttt{,}&p_i&\texttt{,}\ldots\texttt{,}p_n\texttt{)}
    , e) <|' \\
    (c\texttt{(}p_1\texttt{,}\ldots\texttt{,}&p'_i&\texttt{,}\ldots\texttt{,}p_n\texttt{)},
    e')
  \end{eqnalign} \label{eq:gen-2}
\end{eqnarray}

Where \fref{eq:gen-1} holds when $x$ is a fresh variable and
\[
FV_{pat}(c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)}) \cap FV_{exp}(e[x/\kappa
(c\texttt{(}p_1\texttt{,}\ldots\texttt{,}p_n\texttt{)})]) = \emptyset
\]
and \fref{eq:gen-2} holds when
\[
(p_i , e) <|' (p'_i , e')
\]
\end{definition}
\begin{lemma}[Generalisation] \label{lem:gener-patt}
  \[
  (p_1, e_1) <|' (p_2, e_2) \Rightarrow p_1 <' p_2
  \]
\end{lemma}
\begin{proof}
  Straight forward induction proof.
\end{proof}

\begin{definition}[Generalisation of matches $<|$]
Assume that the match is partially ordered, $p_i' <' p_j$, $p_i.e_i <|'
p'_i.e'_i$ then by \fref{lem:gener-patt} we have that $p_i <' p'_i$.

\begin{eqnarray}[c]
  \begin{eqnalign}
    p_1.e_1 \texttt{ |} \ldots \texttt{| } &p_i.e_i& \texttt{ |} \ldots
    \texttt{| } p_n.e_n <| \\ 
    p_1.e_1 \texttt{ |} \ldots \texttt{| } &p'_i.e'_i&
    \texttt{ |} \ldots \texttt{| } p_n.e_n
  \end{eqnalign} \label{eq:gen-all-stay} \\
  \begin{eqnalign}[Ll]
    p_1.e_1 \texttt{ |} \ldots \texttt{| } p_m.e_m \texttt{ |} \ldots \texttt{| }
    p_{q_1}.e_{q_1} \texttt{ |} \ldots \texttt{| } p_{q_k}.e_{q_k} \texttt{ |}
    \ldots \texttt{| } \\ 
    p_{q_l}.e_{q_l} \texttt{ |} \ldots \texttt{| } p_n.e_n <| & \\
    & p_1.e_1 \texttt{ |} \ldots \texttt{| } p_{q_1}.e_{q_1} \texttt{ | }
    p_{q_k}.e_{q_k} \texttt{ | } p_{q_l}.e_{q_l} \texttt{ | } p'_m.e'_m \texttt{
      |} \\ 
    & \ldots \texttt{| } p_n.e_n
  \end{eqnalign} \label{eq:gen-all-move}\\
  \begin{eqnalign}
    p_1.e_1 \texttt{ |} \ldots \texttt{| } p_m.e_m \texttt{ |} &\ldots&
    \texttt{| } p_q.e_q \texttt{ |} \ldots \texttt{| } p_n.e_n <| \\ 
    p_1.e_1 \texttt{ |} \ldots \texttt{| } &m_q.e_q&
    \texttt{ |} \ldots \texttt{| } p_n.e_n
  \end{eqnalign} \label{eq:gen-all-remove}
\end{eqnarray}


Where \ref{eq:gen-all-stay} holds when
\[
(p_i || p_j \land p_i' || p_j) \lor (p_i <' p_j \land p_i' <' p_j) \quad
\texttt{for $j \in \{i+1 \ldots n\}$ }
\]
and \ref{eq:gen-all-move} holds when
\[
p_i || p_j \land p_j <' p_i' \quad \texttt{for $j \in \{i+1 \ldots n\}$ }
\]
and \ref{eq:gen-all-remove} holds when
\[
p_i <' p_j \land p_i' = p_j \quad \texttt{for $j \in \{i+1 \ldots n\}$ }
\]

We name \ref{eq:gen-all-stay} as ``stay'', \ref{eq:gen-all-move} as ``move'' and
\ref{eq:gen-all-remove} as ``remove''.
\end{definition}


% \section{Generalisation with unification of bodys}



% \section{Weak unification}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% reftex-fref-is-default: t
%%% End: 
