\documentclass[a4paper, oneside, draft]{memoir} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\britishhyphenmins}{22} 

% Fix of fancyref to work with memoir. Makes references look
% nice. Redefines memoir \fref and \Fref to \refer and \Refer.
% \usepackage{refer}             %
% As we dont really have any use for \fref and \Fref we just undefine what
% memoir defined them as, so fancyref can define what it wants.
\let\fref\undefined
\let\Fref\undefined
\usepackage{fancyref} % Better reference. 

\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{ulem} % \sout - strike-through
\usepackage{tikz}

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function


\renewcommand{\ttdefault}{txtt} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
%\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\theoremstyle{definition}
\newtheorem{judgement}{Judgement}

\newtheorem{definition}{Definition}

\begin{document}
\chapter{Grammar}
\fixme{remember to introduce new relations.}
\begin{eqnarray*}[rqcql:Tl]
var & = & (a-z)* & Identifiers\\
con & = & (A-Z)(a-z)* & Constructors\\
num & = & \mathbb{Z}    & Natural numbers\\
match & ::= & \epsilon                            & Empty match\\
& & pat\texttt{.}exp\ \texttt{|}\ match               & Pattern -> expression\\
pat & ::= & var                                       & Variable\\
& & con\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} & Where con
has arity $n$\\
exp & ::= & var                                       & Variable\\
& & exp_1 exp_2                                     & Application\\
& & \lambda match                                  & Abstraction\\
& & con\texttt{(}exp_1\texttt{,} \ldots\texttt{,} exp_n\texttt{)} & Where con
has arity $n$\\
dec & ::= & var \mapsto exp                         & Plain value binding\\
& & \texttt{rec}\ var \mapsto \lambda match         & Recursive value binding\\
& & con \texttt{:} \overline{num}                           & Constructor of arity $num$\\
& & \epsilon                             & Empty program\\
& & dec_1 \texttt{;} dec_2                                      & Sequencing
\end{eqnarray*}

\fixme{korte aliaser for syntaktiske kategorier ($p$ for $pat$, $\ldots$)}

\section{Total ordering on patterns}
\fbox{Judgement $pat_1 < pat_2$}\\

Assume a total ordering $<$ on constructors. Inductively defined:
\begin{eqnarray}
con\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} &<& var\\
con_1\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} &<&
con_2\texttt{(}pat'_1\texttt{,} \ldots\texttt{,} pat'_m\texttt{)}\label{eq:con-total-order-2}
\end{eqnarray}
Where \ref{eq:con-total-order-2} holds iff
\begin{eqnarray*}
con_1 &<& con_2 \lor con_1 = con_2 \land (\\
pat_1 &<& pat'_1 \lor pat_1 = pat'_1 \land (\\
&\ldots&\\
pat_n &<& pat'_n\\
&\ldots&\\
&))&
\end{eqnarray*}

\section{Partial ordering on patterns}
\fbox{Judgement $pat_1 \preccurlyeq pat_2$}\\

$pat_2$ generalises $pat_1$ or $pat_1$ is more specific than $pat_2$. Inductively
defined.

\begin{eqnarray}
pat &\preccurlyeq& var\\
con_1\texttt{(}pat_1\texttt{,} \ldots\texttt{,} pat_n\texttt{)} &\preccurlyeq&
con_2\texttt{(}pat'_1\texttt{,} \ldots\texttt{,} pat'_m\texttt{)}\label{eq:con-partial-order-2}
\end{eqnarray}
Where \fref{eq:con-partial-order-2} holds iff
\begin{eqnarray*}
con_1 &=& con_2 \quad \land\\
pat_1 &\preccurlyeq& pat'_1 \quad \land\\
&\ldots&\\
pat_n &\preccurlyeq& pat'_n
\end{eqnarray*}

\section{Elimination of unused patterns}\label{sec:elim-unus-patt}
\fbox{Judgement $match_1 \sqsupset match_2$}\\

Let
\[
m = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|} p_n\texttt{.}e_n
\]
If $p_j \preccurlyeq p_i$ where $j > i$ then 
\[
m \sqsupset m'
\]
where
\[
m' = p_1\texttt{.}e_1 \texttt{|} \ldots \texttt{|}
p_{j-1}\texttt{.}e_{j-1} \texttt{|} p_{j+1}\texttt{.}e_{j+1} \texttt{|}
\ldots \texttt{|} p_n\texttt{.}e_n
\]
In other words; pattern $j$ and its body can be removed from $m$.

\section{Partially ordered form}
\begin{definition}
A match $m = p_1\texttt{.}e_1\texttt{|}\ldots\texttt{|}p_n\texttt{.}e_n$ is in
partially ordered form iff
\[
\forall i \in \{1, \ldots, n\} : p_j \not\preccurlyeq p_i \quad \textnormal{where $j > i$}
\]

Note that every match $m$ can be transformed to an equivalent match $m'$ such
that $m'$ is in partially ordered form, by repeated elimination of unused
patterns (\fref{sec:elim-unus-patt}).
\end{definition}

\section{Generalisation of patterns}
The syntactic category $pat$ is a proper subset of $exp$. Let $\kappa : pat
\rightarrow exp$ be the canonical mapping from $pat$ to $exp$.

Let the free variables of a pattern $FV_{pat} : pat \rightarrow 2^{var}$ be
defined by $FV_{pat} = FV_{exp} \circ \kappa$, where $FV_{exp}$ denotes the free
variables of an expression in the usual sense.\\

\fbox{Judgement $(pat_1, exp_1) \lhd' (pat_2, exp_2)$}\\

Inductively defined
\begin{eqnarray}[c]
(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}pat_n\texttt{)} , exp)
\lhd'
(x , exp[x/\kappa
(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}pat_n\texttt{)})]) \label{eq:gen-1}\\
\begin{eqnalign}
(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}&pat_i&\texttt{,}\ldots\texttt{,}pat_n\texttt{)}
, exp) \ \lhd' \\
(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}&pat'_i&\texttt{,}\ldots\texttt{,}pat_n\texttt{)},
exp')
\end{eqnalign} \label{eq:gen-2}
\end{eqnarray}

Where \fref{eq:gen-1} holds when $x$ is a fresh variable and
\[
FV_{pat}(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}pat_n\texttt{)}) \cap FV_{exp}(exp[x/\kappa
(con\texttt{(}pat_1\texttt{,}\ldots\texttt{,}pat_n\texttt{)})]) = \emptyset
\]
and \fref{eq:gen-2} holds when
\[
(pat_i , exp) \lhd' (pat'_i , exp')
\]

\begin{judgement}[$match_1 \lhd match_2$]
  \begin{eqnarray}
    \begin{eqnalign}
      pat_1.exp_1 \texttt{|} \ldots \texttt{|} &pat_i.exp_i& \texttt{|} \ldots
      \texttt{|} pat_n.exp_n \ \lhd \\
      pat_{\pi(1)}.exp_{\pi(1)} \texttt{|} \ldots \texttt{|} &pat'_{\pi(i)}.exp'_{\pi(i)}& \texttt{|} \ldots
      \texttt{|} pat_{\pi(n)}.exp_{\pi(n)}
    \end{eqnalign}
\end{eqnarray}
When
\[
(pat_i, exp_i) \lhd' (pat'_i, exp'_i) \textnormal{ and } pat_i \preccurlyeq
pat_j \Rightarrow pat'_i \preccurlyeq pat_j
\textnormal{ for } j \in
\{1,\ldots,n\}\]

\end{judgement}


\section{Generalisation with unification of bodys}



\section{Weak unification}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% reftex-fref-is-default: t
%%% End: 
