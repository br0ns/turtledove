\section{Mylib}

The idea behind this base library is to implement the most basic data structures
and algorithms that are not part of the SML definition or any of the default
compilers supply. We have chosen to name the library ``Mylib''.

There is three main design decisions in Mylib:


\fixme{The toString and show functins must take the pr (print function that
  convert the type to a string) and the triple (left, right, delimiter), so the
  ordering dosn't have to define the toString. This could all have been avoided
  with Haskell type classes. }

\begin{enumerate}
\item The main data type of a module is always named \texttt{t}.

\item A module must always implement the function \texttt{toString}. This
  function returns a ``flat'' string representation of the data type. The string
  must always be ``single line''.

\item A module must always implement the function \texttt{show}. This function
  returns a ``2d'' string representation of the data type if possible. It can
  bee seen as a pretty print. 
\end{enumerate}


Below is an example of the above mentioned three design decisions

\begin{example}\
\begin{lstlisting}
structure ListSet :> Set
struct

  type ''a t = ''a list

  (* Sugested default definitions of left, right and delimiter
      l = "{ "
      r = " }"
      d = ", "
   *)
  fun toString _  (l, r, _) nil      = l ^ r
    | toString pr (l, r, d) (h :: t) =
      let
        val x = fold (fn (a, b) => b ^ d ^ (pr a)) (pr h) t 
      in
        l ^ x ^ r
      end

  fun show pr (l, r, d) x = ...
end

\end{lstlisting}
\end{example}

\subsection*{Data structures}

The library will contain standard implementations of sets, maps, trees, etc.

\begin{description}
\item[Set] A generic collection of unique values. The value needs to be an
  equality type so it is possible to do lookups.

  The OrderedSet needs to specify a compare function on values, that returns an
  order (\texttt{LESS}, \texttt{EQUAL} or \texttt{GREATER})

\item[Map] Generic collection of key-value pairs where a unique key maps to an arbitrary
  value. Obviously the type of the key needs to be an equality type before it is
  possible to do lookups by comparing keys.

  The OrderedMap needs to specify a compare function on keys, that returns an
  order (\texttt{LESS}, \texttt{EQUAL} or \texttt{GREATER}).

\item[Dictionary] The dictionary is a specialised ordered map with keys as
  strings.

\fixme{Look at A dictionary implementation based on dynamic perfect hashing
  \url{http://portal.acm.org/citation.cfm?id=1370602}}


\item[Heap] 

\item[Queue] 

\item[Tree] 

  % In the design we can talk about the below mentioned two types.
  % But in the implementation we just say that we have implemented the later.
  
  There is a need for two different kind of trees.
  
  \begin{enumerate}
  \item Ordinary trees, binary as n-ary
    
  \item Trees with enhanced possibility of walking around the nodes by getting a
    list of the children or getting the parent node.
    
    The last will be a necessary feature when representing the syntax trees.

  \end{enumerate}
\end{description}


\subsection*{Algorithms}

\begin{description}
\item[ListSort] 

  % QuickSortList
\end{description}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../report"
%%% End:
